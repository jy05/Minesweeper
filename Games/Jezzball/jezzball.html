<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jezzball - Retro Arcade</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', cursive;
            background-image: url('../../assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        .back-button-top {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(147, 51, 234, 0.4);
        }
        .back-button-top:hover {
            transform: translateY(-2px);
        }
        .game-container {
            background: linear-gradient(145deg, rgba(30, 20, 60, 0.95), rgba(50, 30, 80, 0.95));
            border: 4px solid #9333ea;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.4);
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 rgba(147, 51, 234, 0.8);
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(26, 15, 46, 0.8);
            border: 2px solid #4a148c;
            flex-wrap: wrap;
            gap: 15px;
        }
        .info-item {
            color: #9333ea;
            font-size: 10px;
        }
        .info-value {
            color: #ec4899;
            margin-left: 5px;
        }
        #gameCanvas {
            display: block;
            background: #0a0515;
            border: 4px solid #4a148c;
            margin: 0 auto 15px;
            cursor: none;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        button:hover { transform: translateY(-2px); }
        .back-button { display: none; }
        .message {
            text-align: center;
            color: #ec4899;
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.8;
            min-height: 40px;
        }
        .powerup-container {
            background: rgba(26, 15, 46, 0.6);
            border: 2px solid #4a148c;
            border-radius: 10px;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 700px;
            margin-bottom: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }
        .powerup-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(10, 5, 21, 0.8);
            border: 2px solid transparent;
            border-radius: 5px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .powerup-item.selected {
            border-color: #ec4899;
            background: rgba(236, 72, 153, 0.2);
            box-shadow: 0 0 10px rgba(236, 72, 153, 0.3);
        }
        .powerup-item.active {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
            animation: pulse 1s infinite;
        }
        .powerup-icon {
            font-size: 14px;
            min-width: 20px;
        }
        .powerup-name {
            flex: 1;
            color: #9333ea;
            font-size: 7px;
            line-height: 1.2;
        }
        .powerup-status {
            color: #ec4899;
            font-size: 6px;
        }
        .powerup-help {
            grid-column: 1 / -1;
            text-align: center;
            color: #6b21a8;
            font-size: 7px;
            padding-top: 5px;
            border-top: 1px solid #4a148c;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <button class="back-button-top" onclick="window.location.href='../games.html'">‚Üê Back</button>
    
    <div class="game-container">
        <h1>Jezzball</h1>
        <div class="game-info">
            <div class="info-item">Level: <span class="info-value" id="level">1</span></div>
            <div class="info-item">Lives: <span class="info-value" id="lives">5</span></div>
            <div class="info-item">Walls: <span class="info-value" id="walls">7</span></div>
            <div class="info-item">Filled: <span class="info-value" id="filled">0%</span></div>
            <div class="info-item">Goal: <span class="info-value" id="goal">75%</span></div>
            <div class="info-item">Direction: <span class="info-value" id="direction">Horizontal</span></div>
        </div>
        <div class="message" id="message">Click to build walls! Right-click or SPACE to switch direction!</div>
        
        <!-- Power-up Display -->
        <div class="powerup-container">
            <div class="powerup-item selected" data-powerup="0">
                <div class="powerup-icon">‚ùÑÔ∏è</div>
                <div class="powerup-name">Freeze Time</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="1">
                <div class="powerup-icon">‚ö°</div>
                <div class="powerup-name">Electron Beam</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="2">
                <div class="powerup-icon">üí•</div>
                <div class="powerup-name">Ball Destruction</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="3">
                <div class="powerup-icon">üîÑ</div>
                <div class="powerup-name">Bounce Update</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="4">
                <div class="powerup-icon">‚è±Ô∏è</div>
                <div class="powerup-name">Slow Motion</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="5">
                <div class="powerup-icon">‚ù§Ô∏è</div>
                <div class="powerup-name">Extra Life</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-help">Scroll: Select | Middle Click: Activate</div>
        </div>
        
        <canvas id="gameCanvas" width="700" height="500"></canvas>
        <div class="controls">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn">Pause</button>
            <button id="restartBtn">Restart Level</button>
        </div>
    </div>

    <script>
        const { Engine, World, Bodies, Body, Events, Composite } = Matter;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Physics engine setup with optimized settings for bouncing
        const engine = Engine.create({ 
            gravity: { x: 0, y: 0 },
            enableSleeping: false,
            positionIterations: 10,
            velocityIterations: 8,
            constraintIterations: 4
        });
        engine.timing.timeScale = 1;
        const world = engine.world;
        
        let game = {
            level: 1,
            lives: 5,
            wallsLeft: 7,
            balls: [],
            completedWalls: [],
            buildingWall: null,
            isRunning: false,
            isPaused: false,
            goalPercent: 75,
            fallingSections: [],
            selectedPowerup: 0,
            activePowerups: [],
            permanentlyFilled: new Set() // Track cells that have already been filled
        };
        
        let wallDirection = 'horizontal';
        let mouseX = -100;
        let mouseY = -100;
        const WALL_THICKNESS = 6;
        const WALL_SPEED = 6;
        const GRID_SIZE = 10;
        const GRID_COLS = canvas.width / GRID_SIZE;
        const GRID_ROWS = canvas.height / GRID_SIZE;
        
        // No boundary walls - we'll handle boundaries manually for better control
        
        
        function initLevel() {
            // Remove old balls and walls
            game.balls.forEach(ball => World.remove(world, ball.body));
            game.completedWalls.forEach(wall => World.remove(world, wall));
            
            game.balls = [];
            game.completedWalls = [];
            game.buildingWall = null;
            game.wallsLeft = 5 + game.level * 2;
            game.permanentlyFilled.clear(); // Reset filled areas for new level
            
            const numBalls = Math.min(game.level + 1, 10);
            const speed = 2.5 + game.level * 0.4;
            const usedAngles = new Set();
            
            for (let i = 0; i < numBalls; i++) {
                // Ensure unique angle for each ball
                let angle;
                do {
                    angle = Math.random() * Math.PI * 2;
                } while (usedAngles.has(Math.floor(angle * 10)));
                usedAngles.add(Math.floor(angle * 10));
                
                const ballSpeed = speed * (0.9 + Math.random() * 0.2);
                
                const body = Bodies.circle(
                    canvas.width / 2 + (Math.random() - 0.5) * 100,
                    canvas.height / 2 + (Math.random() - 0.5) * 100,
                    8,
                    {
                        isStatic: true, // Make static so Matter.js doesn't move it
                        isSensor: true, // Allow overlap for flood fill detection
                        label: 'ball'
                    }
                );
                
                World.add(world, body);
                
                game.balls.push({
                    body: body,
                    color: ['#9333ea', '#ec4899', '#3b82f6', '#10b981'][i % 4],
                    trail: [],
                    baseSpeed: ballSpeed, // Base speed for this ball
                    speed: ballSpeed,
                    vx: Math.cos(angle) * ballSpeed,
                    vy: Math.sin(angle) * ballSpeed
                });
            }
            
            updateUI();
            showMessage(`Level ${game.level} - Fill ${game.goalPercent}%!`);
        }
        
        function updateUI() {
            document.getElementById('level').textContent = game.level;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('walls').textContent = game.wallsLeft;
            document.getElementById('direction').textContent = wallDirection.charAt(0).toUpperCase() + wallDirection.slice(1);
            document.getElementById('goal').textContent = game.goalPercent + '%';
            
            const filledPercent = calculateFilledPercent();
            document.getElementById('filled').textContent = filledPercent + '%';
        }
        
        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        function updateBuildingWall() {
            if (!game.buildingWall) return;
            
            const wall = game.buildingWall;
            
            if (wall.direction === 'horizontal') {
                // Extend wall in both directions
                const newWidth = wall.width + WALL_SPEED * 2;
                const newX = wall.x - WALL_SPEED;
                
                // Check left extension
                let leftBlocked = false;
                if (newX <= 0) {
                    wall.x = 0;
                    leftBlocked = true;
                } else {
                    // Check for wall collision on left
                    let leftWallX = null;
                    game.completedWalls.forEach(w => {
                        const bounds = w.bounds;
                        // Check if wall intersects vertically with our horizontal wall
                        if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                            // Check if this wall is to the left and we're about to hit it
                            if (bounds.max.x >= newX && bounds.max.x <= wall.x) {
                                if (leftWallX === null || bounds.max.x > leftWallX) {
                                    leftWallX = bounds.max.x;
                                }
                            }
                        }
                    });
                    
                    if (leftWallX !== null) {
                        wall.x = leftWallX;
                        leftBlocked = true;
                    } else {
                        wall.x = newX;
                    }
                }
                
                // Check right extension
                let rightBlocked = false;
                const newRightEdge = wall.x + newWidth;
                if (newRightEdge >= canvas.width) {
                    wall.width = canvas.width - wall.x;
                    rightBlocked = true;
                } else {
                    // Check for wall collision on right
                    let rightWallX = null;
                    const currentRightEdge = wall.x + wall.width;
                    game.completedWalls.forEach(w => {
                        const bounds = w.bounds;
                        // Check if wall intersects vertically with our horizontal wall
                        if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                            // Check if this wall is to the right and we're about to hit it
                            if (bounds.min.x <= newRightEdge && bounds.min.x >= currentRightEdge) {
                                if (rightWallX === null || bounds.min.x < rightWallX) {
                                    rightWallX = bounds.min.x;
                                }
                            }
                        }
                    });
                    
                    if (rightWallX !== null) {
                        wall.width = rightWallX - wall.x;
                        rightBlocked = true;
                    } else {
                        wall.width = newWidth;
                    }
                }
                
                const hitBall = checkBallCollision(wall);
                if ((leftBlocked && rightBlocked) || hitBall) {
                    completeWall(hitBall);
                }
            } else {
                // Extend wall in both directions
                const newHeight = wall.height + WALL_SPEED * 2;
                const newY = wall.y - WALL_SPEED;
                
                // Check top extension
                let topBlocked = false;
                if (newY <= 0) {
                    wall.y = 0;
                    topBlocked = true;
                } else {
                    // Check for wall collision on top
                    let topWallY = null;
                    game.completedWalls.forEach(w => {
                        const bounds = w.bounds;
                        // Check if wall intersects horizontally with our vertical wall
                        if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                            // Check if this wall is above and we're about to hit it
                            if (bounds.max.y >= newY && bounds.max.y <= wall.y) {
                                if (topWallY === null || bounds.max.y > topWallY) {
                                    topWallY = bounds.max.y;
                                }
                            }
                        }
                    });
                    
                    if (topWallY !== null) {
                        wall.y = topWallY;
                        topBlocked = true;
                    } else {
                        wall.y = newY;
                    }
                }
                
                // Check bottom extension
                let bottomBlocked = false;
                const newBottomEdge = wall.y + newHeight;
                if (newBottomEdge >= canvas.height) {
                    wall.height = canvas.height - wall.y;
                    bottomBlocked = true;
                } else {
                    // Check for wall collision on bottom
                    let bottomWallY = null;
                    const currentBottomEdge = wall.y + wall.height;
                    game.completedWalls.forEach(w => {
                        const bounds = w.bounds;
                        // Check if wall intersects horizontally with our vertical wall
                        if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                            // Check if this wall is below and we're about to hit it
                            if (bounds.min.y <= newBottomEdge && bounds.min.y >= currentBottomEdge) {
                                if (bottomWallY === null || bounds.min.y < bottomWallY) {
                                    bottomWallY = bounds.min.y;
                                }
                            }
                        }
                    });
                    
                    if (bottomWallY !== null) {
                        wall.height = bottomWallY - wall.y;
                        bottomBlocked = true;
                    } else {
                        wall.height = newHeight;
                    }
                }
                
                const hitBall = checkBallCollision(wall);
                if ((topBlocked && bottomBlocked) || hitBall) {
                    completeWall(hitBall);
                }
            }
        }
        
        function checkBallCollision(wall) {
            return game.balls.some(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                return pos.x + radius > wall.x && pos.x - radius < wall.x + wall.width &&
                       pos.y + radius > wall.y && pos.y - radius < wall.y + wall.height;
            });
        }
        
        function completeWall(hitBall) {
            if (hitBall) {
                game.lives--;
                showMessage('Hit by ball! Lost a life!');
                game.buildingWall = null;
                updateUI();
                
                if (game.lives <= 0) {
                    gameOver();
                    return;
                }
            } else {
                const wall = game.buildingWall;
                const wallBody = Bodies.rectangle(
                    wall.x + wall.width / 2,
                    wall.y + wall.height / 2,
                    wall.width,
                    wall.height,
                    { 
                        isStatic: true, 
                        label: 'wall',
                        restitution: 1,
                        friction: 0,
                        slop: 0
                    }
                );
                
                World.add(world, wallBody);
                game.completedWalls.push(wallBody);
                game.wallsLeft--;
                game.buildingWall = null;
                
                // Calculate filled percent and create falling sections
                const filledPercent = calculateFilledPercent();
                createFallingSections();
                
                if (filledPercent >= game.goalPercent) {
                    levelComplete();
                    return;
                }
                
                if (game.wallsLeft <= 0) {
                    showMessage('No walls left!');
                    setTimeout(() => {
                        game.lives--;
                        if (game.lives <= 0) {
                            gameOver();
                        } else {
                            initLevel();
                        }
                    }, 2000);
                    return;
                }
                
                showMessage(`${game.wallsLeft} walls left - ${filledPercent}% filled`);
                updateUI();
            }
        }
        
        function calculateFilledPercent() {
            const accessible = new Set();
            
            // Flood fill from each ball position
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            const totalCells = GRID_COLS * GRID_ROWS;
            const accessibleCells = accessible.size;
            const filledCells = totalCells - accessibleCells;
            
            return Math.floor((filledCells / totalCells) * 100);
        }
        
        function createFallingSections() {
            console.log('=== Creating Falling Sections ===');
            // Get all cells accessible from balls
            const ballAccessible = new Set();
            game.balls.forEach((ball, idx) => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                console.log(`Ball ${idx} at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}) -> grid (${col}, ${row})`);
                floodFill(col, row, ballAccessible);
            });
            console.log(`Total accessible cells: ${ballAccessible.size}`);
            
            // Find all non-accessible regions that aren't walls
            const filledRegions = [];
            const processed = new Set();
            
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    
                    // Skip if already processed or accessible or already permanently filled
                    if (processed.has(key) || ballAccessible.has(key) || game.permanentlyFilled.has(key)) continue;
                    
                    const cellMinX = col * GRID_SIZE;
                    const cellMaxX = (col + 1) * GRID_SIZE;
                    const cellMinY = row * GRID_SIZE;
                    const cellMaxY = (row + 1) * GRID_SIZE;
                    
                    // Check if this cell intersects with a wall
                    let blockedByWall = false;
                    for (let wall of game.completedWalls) {
                        const bounds = wall.bounds;
                        if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                              cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                            blockedByWall = true;
                            break;
                        }
                    }
                    
                    if (!blockedByWall) {
                        // Found a filled cell - gather the entire region
                        const region = [];
                        const stack = [[col, row]];
                        const regionSet = new Set();
                        
                        while (stack.length > 0) {
                            const [c, r] = stack.pop();
                            const k = `${c},${r}`;
                            
                            if (c < 0 || c >= GRID_COLS || r < 0 || r >= GRID_ROWS) continue;
                            if (regionSet.has(k) || ballAccessible.has(k) || processed.has(k)) continue;
                            
                            const cellMinX = c * GRID_SIZE;
                            const cellMaxX = (c + 1) * GRID_SIZE;
                            const cellMinY = r * GRID_SIZE;
                            const cellMaxY = (r + 1) * GRID_SIZE;
                            
                            // Check if cell intersects with a wall
                            let blockedByWall = false;
                            for (let wall of game.completedWalls) {
                                const bounds = wall.bounds;
                                if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                                      cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                                    blockedByWall = true;
                                    break;
                                }
                            }
                            
                            if (blockedByWall) {
                                processed.add(k);
                                continue;
                            }
                            
                            regionSet.add(k);
                            processed.add(k);
                            region.push([c, r]);
                            
                            stack.push([c + 1, r], [c - 1, r], [c, r + 1], [c, r - 1]);
                        }
                        
                        if (region.length > 5) {
                            filledRegions.push(region);
                        }
                    } else {
                        processed.add(key);
                    }
                }
            }
            
            console.log(`Found ${filledRegions.length} filled regions`);
            
            // Create falling animation for each filled region
            filledRegions.forEach((region, idx) => {
                console.log(`Region ${idx}: ${region.length} cells`);
                const minCol = Math.min(...region.map(([c, r]) => c));
                const maxCol = Math.max(...region.map(([c, r]) => c));
                const minRow = Math.min(...region.map(([c, r]) => r));
                const maxRow = Math.max(...region.map(([c, r]) => r));
                console.log(`  Bounds: cols ${minCol}-${maxCol}, rows ${minRow}-${maxRow}`);
                
                // Mark all cells in this region as permanently filled
                region.forEach(([c, r]) => {
                    game.permanentlyFilled.add(`${c},${r}`);
                });
                
                game.fallingSections.push({
                    x: minCol * GRID_SIZE,
                    y: minRow * GRID_SIZE,
                    width: (maxCol - minCol + 1) * GRID_SIZE,
                    height: (maxRow - minRow + 1) * GRID_SIZE,
                    scale: 1,
                    opacity: 1,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    cells: region
                });
            });
        }
        
        function updateFallingSections() {
            game.fallingSections = game.fallingSections.filter(section => {
                section.scale -= 0.025;
                section.rotation += section.rotationSpeed;
                section.opacity -= 0.025;
                section.y += 3; // Fall downward
                return section.scale > 0 && section.opacity > 0;
            });
        }
        
        function updateBallSpeeds() {
            const totalArea = GRID_COLS * GRID_ROWS;
            
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                
                // Calculate accessible area for this ball
                const accessible = new Set();
                floodFill(col, row, accessible);
                const ballArea = accessible.size;
                
                // Speed is inversely proportional to area
                // Full area = base speed, half area = 2x speed, quarter area = 4x speed, etc.
                const areaRatio = Math.max(ballArea / totalArea, 0.01); // Prevent division by zero
                const speedMultiplier = 1 / areaRatio; // Direct inverse relationship
                
                // Update ball speed
                ball.speed = ball.baseSpeed * speedMultiplier;
                
                // Adjust velocity to match new speed while maintaining direction
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (currentSpeed > 0.1) {
                    const ratio = ball.speed / currentSpeed;
                    ball.vx *= ratio;
                    ball.vy *= ratio;
                }
            });
        }
        
        function updateBallPhysics() {
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                const buffer = 3;
                
                // Adaptive substeps based on speed - faster balls get more substeps
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const substeps = Math.max(3, Math.ceil(currentSpeed / 2)); // More steps for faster balls
                
                let x = pos.x;
                let y = pos.y;
                
                const stepVx = ball.vx / substeps;
                const stepVy = ball.vy / substeps;
                
                let bouncedThisFrame = false;
                
                for (let step = 0; step < substeps; step++) {
                    const oldX = x;
                    const oldY = y;
                    
                    // Move X axis
                    x += stepVx;
                    
                    // Boundary check X - STRICT with push-away
                    if (x - radius <= 0) {
                        x = radius + buffer;
                        if (!bouncedThisFrame) {
                            // Ensure strong bounce away from wall
                            const perpComponent = ball.speed * 0.6; // 60% perpendicular
                            const parallelComponent = ball.speed * 0.8; // 80% parallel
                            ball.vx = perpComponent;
                            ball.vy = (ball.vy >= 0 ? 1 : -1) * parallelComponent;
                            // Normalize
                            const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            ball.vx = (ball.vx / mag) * ball.speed;
                            ball.vy = (ball.vy / mag) * ball.speed;
                            bouncedThisFrame = true;
                        }
                    } else if (x + radius >= canvas.width) {
                        x = canvas.width - radius - buffer;
                        if (!bouncedThisFrame) {
                            const perpComponent = ball.speed * 0.6;
                            const parallelComponent = ball.speed * 0.8;
                            ball.vx = -perpComponent;
                            ball.vy = (ball.vy >= 0 ? 1 : -1) * parallelComponent;
                            const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            ball.vx = (ball.vx / mag) * ball.speed;
                            ball.vy = (ball.vy / mag) * ball.speed;
                            bouncedThisFrame = true;
                        }
                    }
                    
                    // Wall collision X with continuous detection
                    if (!bouncedThisFrame) {
                        for (const wall of game.completedWalls) {
                            const bounds = wall.bounds;
                            const wallWidth = bounds.max.x - bounds.min.x;
                            const wallHeight = bounds.max.y - bounds.min.y;
                            
                            if (wallWidth < wallHeight) { // Vertical wall
                                const wallLeft = bounds.min.x;
                                const wallRight = bounds.max.x;
                                const wallTop = bounds.min.y;
                                const wallBottom = bounds.max.y;
                                
                                if (y + radius > wallTop && y - radius < wallBottom) {
                                    if ((oldX + radius <= wallLeft && x + radius > wallLeft) ||
                                        (oldX - radius >= wallRight && x - radius < wallRight) ||
                                        (x + radius > wallLeft && x - radius < wallRight)) {
                                        if (ball.vx > 0) {
                                            x = wallLeft - radius - buffer;
                                        } else {
                                            x = wallRight + radius + buffer;
                                        }
                                        ball.vx = -ball.vx;
                                        const perpComponent = ball.speed * 0.5;
                                        const parallelComponent = ball.speed * 0.87;
                                        ball.vx = (ball.vx >= 0 ? 1 : -1) * perpComponent;
                                        ball.vy = (ball.vy >= 0 ? 1 : -1) * parallelComponent;
                                        const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                                        ball.vx = (ball.vx / mag) * ball.speed;
                                        ball.vy = (ball.vy / mag) * ball.speed;
                                        bouncedThisFrame = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Clamp X strictly
                    x = Math.max(radius + buffer, Math.min(canvas.width - radius - buffer, x));
                    
                    // Move Y axis
                    y += stepVy;
                    
                    // Boundary check Y - STRICT with push-away
                    if (y - radius <= 0) {
                        y = radius + buffer;
                        if (!bouncedThisFrame) {
                            const perpComponent = ball.speed * 0.6;
                            const parallelComponent = ball.speed * 0.8;
                            ball.vx = (ball.vx >= 0 ? 1 : -1) * parallelComponent;
                            ball.vy = perpComponent;
                            const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            ball.vx = (ball.vx / mag) * ball.speed;
                            ball.vy = (ball.vy / mag) * ball.speed;
                            bouncedThisFrame = true;
                        }
                    } else if (y + radius >= canvas.height) {
                        y = canvas.height - radius - buffer;
                        if (!bouncedThisFrame) {
                            const perpComponent = ball.speed * 0.6;
                            const parallelComponent = ball.speed * 0.8;
                            ball.vx = (ball.vx >= 0 ? 1 : -1) * parallelComponent;
                            ball.vy = -perpComponent;
                            const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                            ball.vx = (ball.vx / mag) * ball.speed;
                            ball.vy = (ball.vy / mag) * ball.speed;
                            bouncedThisFrame = true;
                        }
                    }
                    
                    // Wall collision Y with continuous detection
                    if (!bouncedThisFrame) {
                        for (const wall of game.completedWalls) {
                            const bounds = wall.bounds;
                            const wallWidth = bounds.max.x - bounds.min.x;
                            const wallHeight = bounds.max.y - bounds.min.y;
                            
                            if (wallWidth > wallHeight) { // Horizontal wall
                                const wallLeft = bounds.min.x;
                                const wallRight = bounds.max.x;
                                const wallTop = bounds.min.y;
                                const wallBottom = bounds.max.y;
                                
                                if (x + radius > wallLeft && x - radius < wallRight) {
                                    if ((oldY + radius <= wallTop && y + radius > wallTop) ||
                                        (oldY - radius >= wallBottom && y - radius < wallBottom) ||
                                        (y + radius > wallTop && y - radius < wallBottom)) {
                                        if (ball.vy > 0) {
                                            y = wallTop - radius - buffer;
                                        } else {
                                            y = wallBottom + radius + buffer;
                                        }
                                        ball.vy = -ball.vy;
                                        const perpComponent = ball.speed * 0.5;
                                        const parallelComponent = ball.speed * 0.87;
                                        ball.vx = (ball.vx >= 0 ? 1 : -1) * parallelComponent;
                                        ball.vy = (ball.vy >= 0 ? 1 : -1) * perpComponent;
                                        const mag = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                                        ball.vx = (ball.vx / mag) * ball.speed;
                                        ball.vy = (ball.vy / mag) * ball.speed;
                                        bouncedThisFrame = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Clamp Y strictly
                    y = Math.max(radius + buffer, Math.min(canvas.height - radius - buffer, y));
                }
                
                // Normalize speed to match target
                const finalSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (finalSpeed > 0.1) {
                    ball.vx = (ball.vx / finalSpeed) * ball.speed;
                    ball.vy = (ball.vy / finalSpeed) * ball.speed;
                }
                
                // Final strict boundary enforcement
                x = Math.max(radius + buffer, Math.min(canvas.width - radius - buffer, x));
                y = Math.max(radius + buffer, Math.min(canvas.height - radius - buffer, y));
                
                // Detect and prevent wall riding
                const distToLeft = x - radius;
                const distToRight = canvas.width - x - radius;
                const distToTop = y - radius;
                const distToBottom = canvas.height - y - radius;
                const wallProximity = 5; // Pixels
                
                // Check if hugging left/right wall and moving mostly parallel
                if (distToLeft < wallProximity || distToRight < wallProximity) {
                    const absVx = Math.abs(ball.vx);
                    const absVy = Math.abs(ball.vy);
                    // If moving more vertically than horizontally (riding the wall)
                    if (absVy > absVx * 1.5) {
                        // Force away from wall with strong horizontal component
                        const direction = distToLeft < wallProximity ? 1 : -1;
                        ball.vx = direction * ball.speed * 0.7;
                        ball.vy = (ball.vy >= 0 ? 1 : -1) * ball.speed * 0.7;
                        // Push away from wall
                        if (distToLeft < wallProximity) x = radius + buffer + 2;
                        if (distToRight < wallProximity) x = canvas.width - radius - buffer - 2;
                    }
                }
                
                // Check if hugging top/bottom wall and moving mostly parallel
                if (distToTop < wallProximity || distToBottom < wallProximity) {
                    const absVx = Math.abs(ball.vx);
                    const absVy = Math.abs(ball.vy);
                    // If moving more horizontally than vertically (riding the wall)
                    if (absVx > absVy * 1.5) {
                        // Force away from wall with strong vertical component
                        const direction = distToTop < wallProximity ? 1 : -1;
                        ball.vx = (ball.vx >= 0 ? 1 : -1) * ball.speed * 0.7;
                        ball.vy = direction * ball.speed * 0.7;
                        // Push away from wall
                        if (distToTop < wallProximity) y = radius + buffer + 2;
                        if (distToBottom < wallProximity) y = canvas.height - radius - buffer - 2;
                    }
                }
                
                // Update position
                Body.setPosition(ball.body, { x, y });
            });
        }
        
        function updateBallTrails() {
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                ball.trail.push({ x: pos.x, y: pos.y });
                
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const maxTrailLength = Math.floor(15 + speed * 5); // Longer trails at higher speeds
                
                if (ball.trail.length > maxTrailLength) {
                    ball.trail.shift();
                }
            });
        }
        
        function floodFill(startCol, startRow, visited) {
            const stack = [[startCol, startRow]];
            
            while (stack.length > 0) {
                const [col, row] = stack.pop();
                
                if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) continue;
                
                const key = `${col},${row}`;
                if (visited.has(key)) continue;
                
                // Check if this grid cell intersects with any wall
                const cellMinX = col * GRID_SIZE;
                const cellMaxX = (col + 1) * GRID_SIZE;
                const cellMinY = row * GRID_SIZE;
                const cellMaxY = (row + 1) * GRID_SIZE;
                
                let blockedByWall = false;
                for (let wall of game.completedWalls) {
                    const bounds = wall.bounds;
                    // Check if cell area intersects with wall bounds
                    if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                          cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                        blockedByWall = true;
                        break;
                    }
                }
                
                if (blockedByWall) continue;
                
                visited.add(key);
                
                stack.push([col + 1, row], [col - 1, row], [col, row + 1], [col, row - 1]);
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a0a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw filled areas
            const accessible = new Set();
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            // Draw filled areas in one pass
            ctx.fillStyle = '#2d1b4e';
            ctx.beginPath();
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    if (!accessible.has(key)) {
                        ctx.rect(col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            ctx.fill()
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(147, 51, 234, 0.15)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
            
            // Draw completed walls
            ctx.fillStyle = '#9333ea';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#9333ea';
            game.completedWalls.forEach(wall => {
                const bounds = wall.bounds;
                ctx.fillRect(
                    bounds.min.x,
                    bounds.min.y,
                    bounds.max.x - bounds.min.x,
                    bounds.max.y - bounds.min.y
                );
            });
            
            // Draw building wall
            if (game.buildingWall) {
                ctx.fillStyle = '#ec4899';
                ctx.shadowColor = '#ec4899';
                const w = game.buildingWall;
                ctx.fillRect(w.x, w.y, w.width, w.height);
            }
            
            ctx.shadowBlur = 0;
            
            // Draw falling sections
            game.fallingSections.forEach((section, idx) => {
                ctx.save();
                ctx.globalAlpha = section.opacity;
                ctx.translate(section.x + section.width / 2, section.y + section.height / 2);
                ctx.rotate(section.rotation);
                ctx.scale(section.scale, section.scale);
                
                // Create gradient for falling sections
                const gradient = ctx.createLinearGradient(
                    -section.width / 2, -section.height / 2,
                    section.width / 2, section.height / 2
                );
                gradient.addColorStop(0, '#ec4899');
                gradient.addColorStop(0.5, '#9333ea');
                gradient.addColorStop(1, '#3b82f6');
                
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ec4899';
                ctx.fillRect(-section.width / 2, -section.height / 2, section.width, section.height);
                
                ctx.restore();
            });
            
            // Draw ball tracers
            game.balls.forEach(ball => {
                if (ball.trail.length > 1) {
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    for (let i = 1; i < ball.trail.length; i++) {
                        const progress = i / ball.trail.length;
                        const alpha = progress * 0.8;
                        
                        // Draw outer glow
                        ctx.strokeStyle = ball.color;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = ball.color;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                        
                        // Draw bright core
                        ctx.globalAlpha = alpha;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            });
            
            // Draw balls
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = ball.color;
                
                const grad = ctx.createRadialGradient(
                    pos.x - radius * 0.3, pos.y - radius * 0.3, radius * 0.1,
                    pos.x, pos.y, radius
                );
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.3, ball.color);
                grad.addColorStop(1, darkenColor(ball.color, 0.4));
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Rim light
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 0;
                ctx.stroke();
                
                // Highlight shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(pos.x - radius * 0.35, pos.y - radius * 0.35, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Draw cursor direction indicator and crosshair
            if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height && 
                game.isRunning && !game.isPaused) {
                ctx.save();
                
                // Direction line (only when not building)
                if (!game.buildingWall) {
                    ctx.strokeStyle = 'rgba(236, 72, 153, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ec4899';
                    
                    ctx.beginPath();
                    if (wallDirection === 'horizontal') {
                        ctx.moveTo(0, mouseY);
                        ctx.lineTo(canvas.width, mouseY);
                    } else {
                        ctx.moveTo(mouseX, 0);
                        ctx.lineTo(mouseX, canvas.height);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Crosshair
                ctx.strokeStyle = '#ec4899';
                ctx.fillStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ec4899';
                
                ctx.beginPath();
                ctx.moveTo(mouseX - 10, mouseY);
                ctx.lineTo(mouseX - 3, mouseY);
                ctx.moveTo(mouseX + 3, mouseY);
                ctx.lineTo(mouseX + 10, mouseY);
                ctx.moveTo(mouseX, mouseY - 10);
                ctx.lineTo(mouseX, mouseY - 3);
                ctx.moveTo(mouseX, mouseY + 3);
                ctx.lineTo(mouseX, mouseY + 10);
                ctx.stroke();
                
                // Center dot
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function darkenColor(color, factor) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function gameLoop() {
            if (!game.isRunning) return;
            
            if (!game.isPaused) {
                updateBallSpeeds();
                updateBallPhysics();
                updateBuildingWall();
                updateFallingSections();
                updateBallTrails();
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function levelComplete() {
            game.isRunning = false;
            showMessage(`Level ${game.level} Complete!`);
            setTimeout(() => {
                game.level++;
                game.isRunning = true;
                initLevel();
                gameLoop();
            }, 2000);
        }
        
        function gameOver() {
            game.isRunning = false;
            showMessage('Game Over! Click Start to play again.');
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseX = -100;
            mouseY = -100;
        });
        
        canvas.addEventListener('click', e => {
            if (!game.isRunning || game.isPaused || game.buildingWall || game.wallsLeft <= 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (wallDirection === 'horizontal') {
                game.buildingWall = {
                    x: x,
                    y: y - WALL_THICKNESS / 2,
                    width: 0,
                    height: WALL_THICKNESS,
                    direction: 'horizontal'
                };
            } else {
                game.buildingWall = {
                    x: x - WALL_THICKNESS / 2,
                    y: y,
                    width: WALL_THICKNESS,
                    height: 0,
                    direction: 'vertical'
                };
            }
        });
        
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
            updateUI();
        });
        
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
                updateUI();
            }
        });
        
        // Power-up controls
        const powerupItems = document.querySelectorAll('.powerup-item');
        
        document.addEventListener('wheel', e => {
            if (e.deltaY > 0) {
                game.selectedPowerup = (game.selectedPowerup + 1) % powerupItems.length;
            } else {
                game.selectedPowerup = (game.selectedPowerup - 1 + powerupItems.length) % powerupItems.length;
            }
            updatePowerupUI();
        });
        
        document.addEventListener('mousedown', e => {
            if (e.button === 1) {
                e.preventDefault();
                activatePowerup(game.selectedPowerup);
            }
        });
        
        function updatePowerupUI() {
            powerupItems.forEach((item, index) => {
                item.classList.remove('selected');
                if (index === game.selectedPowerup) {
                    item.classList.add('selected');
                }
            });
        }
        
        function activatePowerup(index) {
            const powerupNames = ['Freeze Time', 'Electron Beam', 'Ball Destruction', 'Bounce Update', 'Slow Motion', 'Extra Life'];
            showMessage(`${powerupNames[index]} - Coming Soon!`);
        }
        
        updatePowerupUI();
        
        document.getElementById('startBtn').addEventListener('click', () => {
            game.level = 1;
            game.lives = 5;
            game.isRunning = true;
            game.isPaused = false;
            initLevel();
            gameLoop();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            game.isPaused = !game.isPaused;
            document.getElementById('pauseBtn').textContent = game.isPaused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (game.isRunning) {
                initLevel();
            }
        });
        
        draw();
    </script>
</body>
</html>
