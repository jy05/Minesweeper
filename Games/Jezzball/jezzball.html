<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jezzball - Retro Arcade</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background-image: url('../../assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }

        /* Music Controls */
        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #9333ea;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(147, 51, 234, 0.5);
        }

        .volume-control-game {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider-game {
            width: 120px;
            height: 8px;
            -webkit-appearance: none;
            background: #0a0515;
            border: 2px solid #4a148c;
            border-radius: 0;
            outline: none;
        }

        .volume-slider-game::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 0;
            background: #9333ea;
            cursor: pointer;
            border: 2px solid #ec4899;
        }

        .volume-percent {
            font-size: 10px;
            color: #9333ea;
            min-width: 35px;
        }

        .mute-toggle {
            font-size: 10px;
            padding: 8px 12px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 2px solid #4a148c;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-container {
            background: linear-gradient(145deg, rgba(30, 20, 60, 0.95), rgba(50, 30, 80, 0.95));
            border: 4px solid #9333ea;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.4),
                        inset 0 0 20px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 rgba(147, 51, 234, 0.8),
                         0 0 20px rgba(255, 255, 255, 0.5);
            line-height: 1.6;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(26, 15, 46, 0.8);
            border: 2px solid #4a148c;
            flex-wrap: wrap;
            gap: 15px;
        }

        .info-item {
            color: #9333ea;
            font-size: 10px;
        }

        .info-value {
            color: #ec4899;
            margin-left: 5px;
        }

        #gameCanvas {
            display: block;
            background: #0a0515;
            border: 4px solid #4a148c;
            margin: 0 auto 15px;
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8),
                        0 0 15px rgba(147, 51, 234, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            border-bottom: 4px solid #1a0f2e;
            border-right: 4px solid #1a0f2e;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 0 4px 0 #1a0f2e,
                        0 0 15px rgba(147, 51, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1a0f2e,
                        0 0 20px rgba(147, 51, 234, 0.6);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1a0f2e;
        }

        .back-button {
            font-size: 12px;
            width: 100%;
        }

        .message {
            text-align: center;
            color: #ec4899;
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.8;
            min-height: 40px;
        }
    </style>
</head>
<body>
    <!-- Background Music -->
    <audio id="gameBgMusic" loop>
        <source src="../../assets/music/Vibe Check - 8it8oy.mp3" type="audio/mpeg">
    </audio>

    <!-- Music Controls -->
    <div class="music-controls">
        <div class="volume-control-game">
            <span class="volume-icon" id="volumeIcon">üîä</span>
            <input type="range" id="volumeSlider" class="volume-slider-game" min="0" max="100" value="15">
            <span class="volume-percent" id="volumePercent">15%</span>
        </div>
        <button class="mute-toggle" id="muteToggle">üîá Mute</button>
    </div>

    <div class="game-container">
        <h1>Jezzball</h1>
        
        <div class="game-info">
            <div class="info-item">Level: <span class="info-value" id="level">1</span></div>
            <div class="info-item">Lives: <span class="info-value" id="lives">5</span></div>
            <div class="info-item">Walls: <span class="info-value" id="walls">7</span></div>
            <div class="info-item">Filled: <span class="info-value" id="filled">0%</span></div>
            <div class="info-item">Goal: <span class="info-value" id="goal">75%</span></div>
        </div>

        <div class="message" id="message">Click to build walls and capture 75% of the area!</div>

        <canvas id="gameCanvas" width="700" height="500"></canvas>

        <div class="controls">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn">Pause</button>
            <button id="restartBtn">Restart Level</button>
        </div>

        <button class="back-button" onclick="window.location.href='../games.html'">‚Üê Back to Games</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            level: 1,
            lives: 5,
            wallsLeft: 7,
            balls: [],
            walls: [],
            filledArea: 0,
            goalPercent: 75,
            isRunning: false,
            isPaused: false,
            buildingWall: null,
            grid: []
        };

        const CELL_SIZE = 2;
        const GRID_WIDTH = canvas.width / CELL_SIZE;
        const GRID_HEIGHT = canvas.height / CELL_SIZE;

        // Initialize grid
        function initGrid() {
            gameState.grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
            // Mark borders as filled
            for (let i = 0; i < GRID_HEIGHT; i++) {
                gameState.grid[i][0] = 1;
                gameState.grid[i][GRID_WIDTH - 1] = 1;
            }
            for (let j = 0; j < GRID_WIDTH; j++) {
                gameState.grid[0][j] = 1;
                gameState.grid[GRID_HEIGHT - 1][j] = 1;
            }
        }

        // Initialize level
        function initLevel() {
            gameState.balls = [];
            gameState.walls = [];
            gameState.filledArea = 0;
            gameState.wallsLeft = 5 + gameState.level * 2;
            initGrid();

            // Create balls based on level
            const numBalls = Math.min(gameState.level + 1, 10);
            for (let i = 0; i < numBalls; i++) {
                gameState.balls.push({
                    x: canvas.width / 2 + Math.random() * 100 - 50,
                    y: canvas.height / 2 + Math.random() * 100 - 50,
                    vx: (Math.random() - 0.5) * (2 + gameState.level * 0.3),
                    vy: (Math.random() - 0.5) * (2 + gameState.level * 0.3),
                    radius: 6,
                    color: ['#9333ea', '#ec4899', '#3b82f6', '#10b981'][i % 4]
                });
            }

            updateUI();
            showMessage(`Level ${gameState.level} - Capture ${gameState.goalPercent}%!`);
        }

        // Start game
        function startGame() {
            gameState.level = 1;
            gameState.lives = 5;
            gameState.isRunning = true;
            gameState.isPaused = false;
            initLevel();
            gameLoop();
        }

        // Update UI
        function updateUI() {
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('walls').textContent = gameState.wallsLeft;
            document.getElementById('filled').textContent = gameState.filledArea + '%';
            document.getElementById('goal').textContent = gameState.goalPercent + '%';
        }

        // Show message
        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        // Update balls
        function updateBalls() {
            gameState.balls.forEach(ball => {
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Bounce off walls
                if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                    ball.vx *= -1;
                    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                }
                if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                    ball.vy *= -1;
                    ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));
                }

                // Check collision with completed walls
                gameState.walls.forEach(wall => {
                    if (wall.complete) {
                        if (wall.direction === 'horizontal') {
                            if (Math.abs(ball.y - wall.y) < ball.radius &&
                                ball.x >= wall.x1 && ball.x <= wall.x2) {
                                ball.vy *= -1;
                            }
                        } else {
                            if (Math.abs(ball.x - wall.x) < ball.radius &&
                                ball.y >= wall.y1 && ball.y <= wall.y2) {
                                ball.vx *= -1;
                            }
                        }
                    }
                });
            });
        }

        // Check if ball hits building wall
        function checkBallWallCollision(wall) {
            return gameState.balls.some(ball => {
                if (wall.direction === 'horizontal') {
                    return Math.abs(ball.y - wall.y) < ball.radius &&
                           ball.x >= wall.x1 && ball.x <= wall.x2;
                } else {
                    return Math.abs(ball.x - wall.x) < ball.radius &&
                           ball.y >= wall.y1 && ball.y <= wall.y2;
                }
            });
        }

        // Build wall
        function buildWall(direction, x, y) {
            if (gameState.wallsLeft <= 0) return;

            const wall = {
                direction,
                x1: x,
                y1: y,
                x2: x,
                y2: y,
                x,
                y,
                speed: 3,
                complete: false
            };

            gameState.buildingWall = wall;
        }

        // Update building wall
        function updateBuildingWall() {
            if (!gameState.buildingWall) return;

            const wall = gameState.buildingWall;
            
            if (wall.direction === 'horizontal') {
                wall.x1 -= wall.speed;
                wall.x2 += wall.speed;

                if (wall.x1 <= 0) wall.x1 = 0;
                if (wall.x2 >= canvas.width) wall.x2 = canvas.width;

                if ((wall.x1 <= 0 && wall.x2 >= canvas.width) || 
                    checkBallWallCollision(wall)) {
                    completeWall();
                }
            } else {
                wall.y1 -= wall.speed;
                wall.y2 += wall.speed;

                if (wall.y1 <= 0) wall.y1 = 0;
                if (wall.y2 >= canvas.height) wall.y2 = canvas.height;

                if ((wall.y1 <= 0 && wall.y2 >= canvas.height) || 
                    checkBallWallCollision(wall)) {
                    completeWall();
                }
            }
        }

        // Complete wall
        function completeWall() {
            const wall = gameState.buildingWall;
            
            if (checkBallWallCollision(wall)) {
                gameState.lives--;
                showMessage('Hit by ball! Lost a life!');
                if (gameState.lives <= 0) {
                    gameOver();
                }
            } else {
                wall.complete = true;
                gameState.walls.push(wall);
                gameState.wallsLeft--;
                fillAreas();
                
                if (gameState.filledArea >= gameState.goalPercent) {
                    levelComplete();
                } else if (gameState.wallsLeft <= 0) {
                    showMessage('No walls left! Try again!');
                    setTimeout(() => {
                        gameState.lives--;
                        if (gameState.lives <= 0) {
                            gameOver();
                        } else {
                            initLevel();
                        }
                    }, 2000);
                }
            }
            
            gameState.buildingWall = null;
            updateUI();
        }

        // Fill areas using flood fill
        function fillAreas() {
            const tempGrid = gameState.grid.map(row => [...row]);
            
            // Mark completed walls
            gameState.walls.forEach(wall => {
                if (wall.complete) {
                    if (wall.direction === 'horizontal') {
                        const y = Math.floor(wall.y / CELL_SIZE);
                        for (let x = Math.floor(wall.x1 / CELL_SIZE); x <= Math.floor(wall.x2 / CELL_SIZE); x++) {
                            if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                                tempGrid[y][x] = 1;
                            }
                        }
                    } else {
                        const x = Math.floor(wall.x / CELL_SIZE);
                        for (let y = Math.floor(wall.y1 / CELL_SIZE); y <= Math.floor(wall.y2 / CELL_SIZE); y++) {
                            if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                                tempGrid[y][x] = 1;
                            }
                        }
                    }
                }
            });

            // Flood fill from each ball position
            const ballAreas = new Set();
            gameState.balls.forEach(ball => {
                const bx = Math.floor(ball.x / CELL_SIZE);
                const by = Math.floor(ball.y / CELL_SIZE);
                floodFill(tempGrid, bx, by, ballAreas);
            });

            // Count filled cells
            let filledCells = 0;
            let totalCells = GRID_WIDTH * GRID_HEIGHT;
            
            for (let i = 0; i < GRID_HEIGHT; i++) {
                for (let j = 0; j < GRID_WIDTH; j++) {
                    if (tempGrid[i][j] === 1 || !ballAreas.has(i * GRID_WIDTH + j)) {
                        filledCells++;
                    }
                }
            }

            gameState.filledArea = Math.floor((filledCells / totalCells) * 100);
            gameState.grid = tempGrid;
            updateUI();
        }

        // Flood fill algorithm
        function floodFill(grid, x, y, visited) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return;
            if (grid[y][x] === 1) return;
            
            const key = y * GRID_WIDTH + x;
            if (visited.has(key)) return;
            
            visited.add(key);
            floodFill(grid, x + 1, y, visited);
            floodFill(grid, x - 1, y, visited);
            floodFill(grid, x, y + 1, visited);
            floodFill(grid, x, y - 1, visited);
        }

        // Level complete
        function levelComplete() {
            gameState.isRunning = false;
            showMessage(`Level ${gameState.level} Complete! Get ready for level ${gameState.level + 1}!`);
            setTimeout(() => {
                gameState.level++;
                gameState.isRunning = true;
                initLevel();
            }, 3000);
        }

        // Game over
        function gameOver() {
            gameState.isRunning = false;
            showMessage('Game Over! Click Start to play again.');
        }

        // Draw
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw filled areas
            ctx.fillStyle = '#1a0f2e';
            for (let i = 0; i < GRID_HEIGHT; i++) {
                for (let j = 0; j < GRID_WIDTH; j++) {
                    if (gameState.grid[i][j] === 1) {
                        ctx.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw completed walls
            ctx.strokeStyle = '#9333ea';
            ctx.lineWidth = 3;
            gameState.walls.forEach(wall => {
                if (wall.complete) {
                    ctx.beginPath();
                    if (wall.direction === 'horizontal') {
                        ctx.moveTo(wall.x1, wall.y);
                        ctx.lineTo(wall.x2, wall.y);
                    } else {
                        ctx.moveTo(wall.x, wall.y1);
                        ctx.lineTo(wall.x, wall.y2);
                    }
                    ctx.stroke();
                }
            });

            // Draw building wall
            if (gameState.buildingWall) {
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const wall = gameState.buildingWall;
                if (wall.direction === 'horizontal') {
                    ctx.moveTo(wall.x1, wall.y);
                    ctx.lineTo(wall.x2, wall.y);
                } else {
                    ctx.moveTo(wall.x, wall.y1);
                    ctx.lineTo(wall.x, wall.y2);
                }
                ctx.stroke();
            }

            // Draw balls
            gameState.balls.forEach(ball => {
                ctx.fillStyle = ball.color;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Game loop
        function gameLoop() {
            if (!gameState.isRunning) return;
            if (!gameState.isPaused) {
                updateBalls();
                updateBuildingWall();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            if (!gameState.isRunning || gameState.isPaused || gameState.buildingWall) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Determine direction based on position
            const horizontal = Math.abs(x - canvas.width / 2) > Math.abs(y - canvas.height / 2);
            buildWall(horizontal ? 'horizontal' : 'vertical', x, y);
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            if (gameState.isRunning) {
                initLevel();
            }
        });

        // Music controls
        const gameBgMusic = document.getElementById('gameBgMusic');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeIcon = document.getElementById('volumeIcon');
        const volumePercent = document.getElementById('volumePercent');
        const muteToggle = document.getElementById('muteToggle');
        
        gameBgMusic.volume = 0.15;
        let isMusicMuted = false;
        
        gameBgMusic.play().catch(() => {
            const startMusic = () => {
                gameBgMusic.play().catch(e => console.log('Music play failed:', e));
            };
            document.addEventListener('click', startMusic, { once: true });
        });
        
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            gameBgMusic.volume = volume;
            volumePercent.textContent = e.target.value + '%';
            volumeIcon.textContent = volume === 0 ? 'üîá' : volume < 0.5 ? 'üîâ' : 'üîä';
        });
        
        muteToggle.addEventListener('click', () => {
            if (isMusicMuted) {
                gameBgMusic.play();
                muteToggle.textContent = 'üîá Mute';
                isMusicMuted = false;
            } else {
                gameBgMusic.pause();
                muteToggle.textContent = 'üîä Unmute';
                isMusicMuted = true;
            }
        });

        // Initialize
        initGrid();
        draw();
    </script>
</body>
</html>
