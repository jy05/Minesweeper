<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jezzball - Retro Arcade</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', cursive;
            background-image: url('../../assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        .back-button-top {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(147, 51, 234, 0.4);
        }
        .back-button-top:hover {
            transform: translateY(-2px);
        }
        .game-container {
            background: linear-gradient(145deg, rgba(30, 20, 60, 0.95), rgba(50, 30, 80, 0.95));
            border: 4px solid #9333ea;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.4);
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 rgba(147, 51, 234, 0.8);
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(26, 15, 46, 0.8);
            border: 2px solid #4a148c;
            flex-wrap: wrap;
            gap: 15px;
        }
        .info-item {
            color: #9333ea;
            font-size: 10px;
        }
        .info-value {
            color: #ec4899;
            margin-left: 5px;
        }
        #gameCanvas {
            display: block;
            background: #0a0515;
            border: 4px solid #4a148c;
            margin: 0 auto 15px;
            cursor: none;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        button:hover { transform: translateY(-2px); }
        .back-button { display: none; }
        .message {
            text-align: center;
            color: #ec4899;
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.8;
            min-height: 40px;
        }
        .powerup-container {
            background: rgba(26, 15, 46, 0.6);
            border: 2px solid #4a148c;
            border-radius: 10px;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 700px;
            margin-bottom: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }
        .powerup-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(10, 5, 21, 0.8);
            border: 2px solid transparent;
            border-radius: 5px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .powerup-item.selected {
            border-color: #ec4899;
            background: rgba(236, 72, 153, 0.2);
            box-shadow: 0 0 10px rgba(236, 72, 153, 0.3);
        }
        .powerup-item.active {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
            animation: pulse 1s infinite;
        }
        .powerup-icon {
            font-size: 14px;
            min-width: 20px;
        }
        .powerup-name {
            flex: 1;
            color: #9333ea;
            font-size: 7px;
            line-height: 1.2;
        }
        .powerup-status {
            color: #ec4899;
            font-size: 6px;
        }
        .powerup-help {
            grid-column: 1 / -1;
            text-align: center;
            color: #6b21a8;
            font-size: 7px;
            padding-top: 5px;
            border-top: 1px solid #4a148c;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Splash Screen Styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(145deg, rgba(10, 5, 21, 0.98), rgba(30, 15, 51, 0.98));
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease;
        }
        .splash-screen.hidden {
            display: none;
        }
        .splash-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }
        .splash-title {
            font-size: 48px;
            color: #ec4899;
            text-shadow: 
                0 0 20px rgba(236, 72, 153, 0.8),
                0 0 40px rgba(147, 51, 234, 0.6),
                4px 4px 0 rgba(147, 51, 234, 0.8);
            margin-bottom: 15px;
            animation: titleGlow 2s ease-in-out infinite;
        }
        .splash-subtitle {
            font-size: 14px;
            color: #9333ea;
            margin-bottom: 40px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }
        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }
        .mode-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            padding: 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 4px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .mode-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 30px rgba(236, 72, 153, 0.6);
            border-color: #ec4899;
        }
        .mode-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        .mode-button:hover::before {
            left: 100%;
        }
        .mode-title {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .mode-desc {
            display: block;
            font-size: 7px;
            color: #ec4899;
            line-height: 1.4;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(236, 72, 153, 0.8), 0 0 40px rgba(147, 51, 234, 0.6), 4px 4px 0 rgba(147, 51, 234, 0.8); }
            50% { text-shadow: 0 0 30px rgba(236, 72, 153, 1), 0 0 60px rgba(147, 51, 234, 0.8), 4px 4px 0 rgba(147, 51, 234, 0.8); }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <button class="back-button-top" onclick="window.location.href='../games.html'">‚Üê Back</button>
    
    <!-- Splash Screen -->
    <div class="splash-screen" id="splashScreen">
        <div class="splash-content">
            <div class="splash-title">JEZZBALL</div>
            <div class="splash-subtitle">Retro Arcade Classic</div>
            <div class="mode-buttons">
                <button class="mode-button" onclick="startGame('normal')">
                    <span class="mode-title">NORMAL</span>
                    <span class="mode-desc">Unlimited walls, lose lives when hit</span>
                </button>
                <button class="mode-button" onclick="startGame('timeattack')">
                    <span class="mode-title">TIME ATTACK</span>
                    <span class="mode-desc">Race against the clock!</span>
                </button>
                <button class="mode-button" onclick="startGame('survival')">
                    <span class="mode-title">SURVIVAL</span>
                    <span class="mode-desc">Limited walls per level</span>
                </button>
                <button class="mode-button" onclick="startGame('freeplay')">
                    <span class="mode-title">FREE PLAY</span>
                    <span class="mode-desc">Unlimited continues, endless fun!</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="game-container" id="gameContainer" style="display: none;">
        <h1>Jezzball</h1>
        <div class="game-info">
            <div class="info-item">Mode: <span class="info-value" id="gameMode">Normal</span></div>
            <div class="info-item">Level: <span class="info-value" id="level">1</span></div>
            <div class="info-item">Lives: <span class="info-value" id="lives">5</span></div>
            <div class="info-item">Walls: <span class="info-value" id="walls">7</span></div>
            <div class="info-item">Filled: <span class="info-value" id="filled">0%</span></div>
            <div class="info-item">Goal: <span class="info-value" id="goal">75%</span></div>
            <div class="info-item">Direction: <span class="info-value" id="direction">Horizontal</span></div>
        </div>
        <div class="message" id="message">Click to build walls! Right-click or SPACE to switch direction!</div>
        
        <!-- Power-up Display -->
        <div class="powerup-container">
            <div class="powerup-item selected" data-powerup="0">
                <div class="powerup-icon">‚ùÑÔ∏è</div>
                <div class="powerup-name">Freeze Time</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="1">
                <div class="powerup-icon">‚ö°</div>
                <div class="powerup-name">Electron Beam</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="2">
                <div class="powerup-icon">üí•</div>
                <div class="powerup-name">Ball Destruction</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="3">
                <div class="powerup-icon">üîÑ</div>
                <div class="powerup-name">Bounce Update</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="4">
                <div class="powerup-icon">‚è±Ô∏è</div>
                <div class="powerup-name">Slow Motion</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="5">
                <div class="powerup-icon">‚ûï</div>
                <div class="powerup-name">Extra Wall</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="6">
                <div class="powerup-icon">üîÑüí´</div>
                <div class="powerup-name">Second Chance</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-help">Scroll: Select | Middle Click: Activate</div>
        </div>
        
        <canvas id="gameCanvas" width="700" height="500"></canvas>
        <div class="controls">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn">Pause</button>
            <button id="restartBtn">Restart Level</button>
        </div>
    </div>

    <script>
        const { Engine, World, Bodies, Body, Events, Composite } = Matter;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Physics engine setup with optimized settings for bouncing
        const engine = Engine.create({ 
            gravity: { x: 0, y: 0 },
            enableSleeping: false,
            positionIterations: 10,
            velocityIterations: 8,
            constraintIterations: 4
        });
        engine.timing.timeScale = 1;
        const world = engine.world;
        
        let game = {
            gameMode: 'normal', // 'normal', 'timeattack', 'survival', 'freeplay'
            level: 1,
            lives: 5,
            wallsLeft: 7,
            balls: [],
            completedWalls: [],
            buildingWalls: [], // Changed to array for multiple simultaneous walls
            isRunning: false,
            isPaused: false,
            goalPercent: 75,
            fallingSections: [],
            selectedPowerup: 0,
            activePowerups: [],
            permanentlyFilled: new Set(), // Track cells that have already been filled
            collisionEffects: [], // Ball collision sparkle effects
            powerupsUnlocked: [false, false, false, false, false, false, false], // 7 power-ups
            powerupsUsed: [false, false, false, false, false, false, false],
            // Tracking for unlock conditions
            levelStartTime: 0,
            wallsPlacedThisLevel: 0,
            wallsLostThisLevel: 0,
            hiddenWalls: [], // Hidden wall pickups in current level
            levelsCompleted: 0,
            // Time Attack mode
            timeRemaining: 0,
            baseLevelTime: 60, // Starting time for first level
            // Survival mode
            wallsUsedThisLevel: 0,
            // Active power-up states
            freezeTimeActive: false,
            slowMotionActive: false,
            slowMotionEndTime: 0,
            electronBeamActive: false,
            electronBeamStart: null,
            shatterEffects: [] // Wall destruction particles
        };
        
        let wallDirection = 'horizontal';
        let mouseX = -100;
        let mouseY = -100;
        const WALL_THICKNESS = 6;
        const WALL_SPEED = 6;
        const GRID_SIZE = 10;
        const GRID_COLS = canvas.width / GRID_SIZE;
        const GRID_ROWS = canvas.height / GRID_SIZE;
        
        // No boundary walls - we'll handle boundaries manually for better control
        
        // Start game with selected mode
        function startGame(mode) {
            // Hide splash screen
            document.getElementById('splashScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            
            // Set game mode
            game.gameMode = mode;
            
            // Initialize mode-specific variables
            if (mode === 'timeattack') {
                game.timeRemaining = game.baseLevelTime;
            } else if (mode === 'survival') {
                // Survival mode uses wallsLeft system
                game.wallsLeft = 7;
            }
            
            // Reset game state
            game.level = 1;
            game.lives = 5;
            game.isRunning = true;
            game.isPaused = false;
            game.powerupsUnlocked = [false, false, false, false, false, false, false];
            game.powerupsUsed = [false, false, false, false, false, false, false];
            game.levelsCompleted = 0;
            
            // Start the game
            initLevel();
            gameLoop();
        }
        
        function initLevel() {
            // Remove old balls and walls
            game.balls.forEach(ball => World.remove(world, ball.body));
            game.completedWalls.forEach(wall => World.remove(world, wall));
            
            game.balls = [];
            game.completedWalls = [];
            game.buildingWalls = [];
            
            // Only set wallsLeft in Survival mode
            if (game.gameMode === 'survival') {
                game.wallsLeft = 5 + game.level * 2;
            }
            
            game.permanentlyFilled.clear(); // Reset filled areas for new level
            
            // Reset level tracking
            game.levelStartTime = Date.now();
            game.wallsPlacedThisLevel = 0;
            game.wallsLostThisLevel = 0;
            
            // Spawn hidden walls (0-3, weighted towards 0-1)
            game.hiddenWalls = [];
            const rand = Math.random();
            let hiddenWallCount = 0;
            if (rand < 0.4) hiddenWallCount = 0;      // 40% chance
            else if (rand < 0.85) hiddenWallCount = 1; // 45% chance
            else if (rand < 0.98) hiddenWallCount = 2; // 13% chance
            else hiddenWallCount = 3;                   // 2% chance
            
            for (let i = 0; i < hiddenWallCount; i++) {
                game.hiddenWalls.push({
                    col: Math.floor(Math.random() * GRID_COLS),
                    row: Math.floor(Math.random() * GRID_ROWS),
                    collected: false
                });
            }
            
            const numBalls = Math.min(game.level + 1, 10);
            const speed = 2.5 + game.level * 0.4;
            const usedAngles = new Set();
            
            for (let i = 0; i < numBalls; i++) {
                // Ensure unique angle for each ball
                let angle;
                do {
                    angle = Math.random() * Math.PI * 2;
                } while (usedAngles.has(Math.floor(angle * 10)));
                usedAngles.add(Math.floor(angle * 10));
                
                const ballSpeed = speed * (0.9 + Math.random() * 0.2);
                
                const body = Bodies.circle(
                    canvas.width / 2 + (Math.random() - 0.5) * 100,
                    canvas.height / 2 + (Math.random() - 0.5) * 100,
                    8,
                    {
                        isStatic: true, // Make static so Matter.js doesn't move it
                        isSensor: true, // Allow overlap for flood fill detection
                        label: 'ball'
                    }
                );
                
                World.add(world, body);
                
                game.balls.push({
                    body: body,
                    color: ['#9333ea', '#ec4899', '#3b82f6', '#10b981'][i % 4],
                    trail: [],
                    baseSpeed: ballSpeed, // Base speed for this ball
                    speed: ballSpeed,
                    vx: Math.cos(angle) * ballSpeed,
                    vy: Math.sin(angle) * ballSpeed
                });
            }
            
            updateUI();
            showMessage(`Level ${game.level} - Fill ${game.goalPercent}%!`);
        }
        
        function updateUI() {
            // Update mode display
            const modeNames = {
                'normal': 'Normal',
                'timeattack': 'Time Attack',
                'survival': 'Survival',
                'freeplay': 'Free Play'
            };
            document.getElementById('gameMode').textContent = modeNames[game.gameMode] || 'Normal';
            
            document.getElementById('level').textContent = game.level;
            document.getElementById('lives').textContent = game.lives;
            
            // Show walls counter only in Survival mode, show timer in Time Attack mode
            const wallsElement = document.getElementById('walls').parentElement;
            if (game.gameMode === 'survival') {
                document.getElementById('walls').textContent = game.wallsLeft;
                // Reset label in case it was changed
                const label = wallsElement.firstChild;
                if (label.nodeType === 3) { // Text node
                    label.textContent = 'Walls: ';
                }
                wallsElement.style.display = '';
            } else if (game.gameMode === 'timeattack') {
                const minutes = Math.floor(game.timeRemaining / 60);
                const seconds = Math.floor(game.timeRemaining % 60);
                document.getElementById('walls').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                // Update label
                const label = wallsElement.firstChild;
                if (label.nodeType === 3) {
                    label.textContent = 'Time: ';
                }
                wallsElement.style.display = '';
            } else {
                wallsElement.style.display = 'none'; // Hide in Normal/Free Play modes
            }
            
            document.getElementById('direction').textContent = wallDirection.charAt(0).toUpperCase() + wallDirection.slice(1);
            document.getElementById('goal').textContent = game.goalPercent + '%';
            
            const filledPercent = calculateFilledPercent();
            document.getElementById('filled').textContent = filledPercent + '%';
        }
        
        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        function updateBuildingWall() {
            // Update all building walls
            game.buildingWalls = game.buildingWalls.filter((wall, wallIndex) => {
                if (wall.direction === 'horizontal') {
                    // Extend wall in both directions
                    const newWidth = wall.width + WALL_SPEED * 2;
                    const newX = wall.x - WALL_SPEED;
                    
                    // Check left extension
                    let leftBlocked = false;
                    if (newX <= 0) {
                        wall.x = 0;
                        leftBlocked = true;
                    } else {
                        // Check for completed wall collision on left
                        let leftWallX = null;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                                if (bounds.max.x >= newX && bounds.max.x <= wall.x) {
                                    if (leftWallX === null || bounds.max.x > leftWallX) {
                                        leftWallX = bounds.max.x;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on left
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            const otherRight = otherWall.x + otherWall.width;
                            if (wall.y + WALL_THICKNESS > otherWall.y && wall.y < otherWall.y + otherWall.height) {
                                if (otherRight >= newX && otherRight <= wall.x) {
                                    if (leftWallX === null || otherRight > leftWallX) {
                                        leftWallX = otherRight;
                                    }
                                }
                            }
                        });
                        
                        if (leftWallX !== null) {
                            wall.x = leftWallX;
                            leftBlocked = true;
                        } else {
                            wall.x = newX;
                        }
                    }
                    
                    // Check right extension
                    let rightBlocked = false;
                    const newRightEdge = wall.x + newWidth;
                    if (newRightEdge >= canvas.width) {
                        wall.width = canvas.width - wall.x;
                        rightBlocked = true;
                    } else {
                        // Check for completed wall collision on right
                        let rightWallX = null;
                        const currentRightEdge = wall.x + wall.width;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                                if (bounds.min.x <= newRightEdge && bounds.min.x >= currentRightEdge) {
                                    if (rightWallX === null || bounds.min.x < rightWallX) {
                                        rightWallX = bounds.min.x;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on right
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            if (wall.y + WALL_THICKNESS > otherWall.y && wall.y < otherWall.y + otherWall.height) {
                                if (otherWall.x <= newRightEdge && otherWall.x >= currentRightEdge) {
                                    if (rightWallX === null || otherWall.x < rightWallX) {
                                        rightWallX = otherWall.x;
                                    }
                                }
                            }
                        });
                        
                        if (rightWallX !== null) {
                            wall.width = rightWallX - wall.x;
                            rightBlocked = true;
                        } else {
                            wall.width = newWidth;
                        }
                    }
                    
                    const hitBall = checkBallCollision(wall);
                    
                    // Electron Beam walls are indestructible - always complete
                    if (wall.isElectronBeam) {
                        if (leftBlocked && rightBlocked) {
                            completeWall(wall, false); // Never loses a life
                            return false; // Remove from array
                        }
                    } else {
                        // Normal walls - building walls are destroyed immediately when hit
                        if ((leftBlocked && rightBlocked) || hitBall) {
                            completeWall(wall, hitBall);
                            return false; // Remove from array
                        }
                    }
                } else {
                    // Vertical wall
                    const newHeight = wall.height + WALL_SPEED * 2;
                    const newY = wall.y - WALL_SPEED;
                    
                    // Check top extension
                    let topBlocked = false;
                    if (newY <= 0) {
                        wall.y = 0;
                        topBlocked = true;
                    } else {
                        // Check for completed wall collision on top
                        let topWallY = null;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                                if (bounds.max.y >= newY && bounds.max.y <= wall.y) {
                                    if (topWallY === null || bounds.max.y > topWallY) {
                                        topWallY = bounds.max.y;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on top
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            const otherBottom = otherWall.y + otherWall.height;
                            if (wall.x + WALL_THICKNESS > otherWall.x && wall.x < otherWall.x + otherWall.width) {
                                if (otherBottom >= newY && otherBottom <= wall.y) {
                                    if (topWallY === null || otherBottom > topWallY) {
                                        topWallY = otherBottom;
                                    }
                                }
                            }
                        });
                        
                        if (topWallY !== null) {
                            wall.y = topWallY;
                            topBlocked = true;
                        } else {
                            wall.y = newY;
                        }
                    }
                    
                    // Check bottom extension
                    let bottomBlocked = false;
                    const newBottomEdge = wall.y + newHeight;
                    if (newBottomEdge >= canvas.height) {
                        wall.height = canvas.height - wall.y;
                        bottomBlocked = true;
                    } else {
                        // Check for completed wall collision on bottom
                        let bottomWallY = null;
                        const currentBottomEdge = wall.y + wall.height;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                                if (bounds.min.y <= newBottomEdge && bounds.min.y >= currentBottomEdge) {
                                    if (bottomWallY === null || bounds.min.y < bottomWallY) {
                                        bottomWallY = bounds.min.y;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on bottom
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            if (wall.x + WALL_THICKNESS > otherWall.x && wall.x < otherWall.x + otherWall.width) {
                                if (otherWall.y <= newBottomEdge && otherWall.y >= currentBottomEdge) {
                                    if (bottomWallY === null || otherWall.y < bottomWallY) {
                                        bottomWallY = otherWall.y;
                                    }
                                }
                            }
                        });
                        
                        if (bottomWallY !== null) {
                            wall.height = bottomWallY - wall.y;
                            bottomBlocked = true;
                        } else {
                            wall.height = newHeight;
                        }
                    }
                    
                    const hitBall = checkBallCollision(wall);
                    
                    // Electron Beam walls are indestructible - always complete
                    if (wall.isElectronBeam) {
                        if (topBlocked && bottomBlocked) {
                            completeWall(wall, false); // Never loses a life
                            return false; // Remove from array
                        }
                    } else {
                        // Normal walls - building walls are destroyed immediately when hit
                        if ((topBlocked && bottomBlocked) || hitBall) {
                            completeWall(wall, hitBall);
                            return false; // Remove from array
                        }
                    }
                }
                
                return true; // Keep in array
            });
        }
        
        function checkBallCollision(wall) {
            // Return the ball that collided, or null if no collision
            for (let ball of game.balls) {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                if (pos.x + radius > wall.x && pos.x - radius < wall.x + wall.width &&
                    pos.y + radius > wall.y && pos.y - radius < wall.y + wall.height) {
                    return ball;
                }
            }
            return null;
        }
        
        function completeWall(wall, hitBall) {
            if (hitBall) {
                game.lives--;
                game.wallsLostThisLevel++;
                showMessage('Hit by ball! Lost a life!');
                updateUI();
                
                if (game.lives <= 0) {
                    gameOver();
                    return;
                }
            } else {
                game.wallsPlacedThisLevel++;
                
                const wallBody = Bodies.rectangle(
                    wall.x + wall.width / 2,
                    wall.y + wall.height / 2,
                    wall.width,
                    wall.height,
                    { 
                        isStatic: true, 
                        label: 'wall',
                        restitution: 1,
                        friction: 0,
                        slop: 0
                    }
                );
                
                World.add(world, wallBody);
                game.completedWalls.push(wallBody);
                
                // Calculate filled percent and create falling sections
                const filledPercent = calculateFilledPercent();
                createFallingSections();
                
                if (filledPercent >= game.goalPercent) {
                    levelComplete();
                    return;
                }
                
                if (game.wallsLeft <= 0 && game.buildingWalls.length === 0) {
                    showMessage('No walls left!');
                    setTimeout(() => {
                        game.lives--;
                        game.wallsLostThisLevel++;
                        if (game.lives <= 0) {
                            gameOver();
                        } else {
                            initLevel();
                        }
                    }, 2000);
                    return;
                }
                
                showMessage(`${game.wallsLeft} walls left - ${filledPercent}% filled`);
                updateUI();
            }
        }
        
        function calculateFilledPercent() {
            const accessible = new Set();
            
            // Flood fill from each ball position
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            const totalCells = GRID_COLS * GRID_ROWS;
            const accessibleCells = accessible.size;
            const filledCells = totalCells - accessibleCells;
            
            return Math.floor((filledCells / totalCells) * 100);
        }
        
        function createFallingSections() {
            console.log('=== Creating Falling Sections ===');
            // Get all cells accessible from balls (check multiple points around each ball)
            const ballAccessible = new Set();
            game.balls.forEach((ball, idx) => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                // Check center and points around the ball to ensure we catch the area
                const checkPoints = [
                    [pos.x, pos.y], // center
                    [pos.x - radius, pos.y], // left
                    [pos.x + radius, pos.y], // right
                    [pos.x, pos.y - radius], // top
                    [pos.x, pos.y + radius]  // bottom
                ];
                
                checkPoints.forEach(([x, y]) => {
                    const col = Math.floor(x / GRID_SIZE);
                    const row = Math.floor(y / GRID_SIZE);
                    if (col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS) {
                        console.log(`Ball ${idx} checking (${x.toFixed(1)}, ${y.toFixed(1)}) -> grid (${col}, ${row})`);
                        floodFill(col, row, ballAccessible);
                    }
                });
            });
            console.log(`Total accessible cells: ${ballAccessible.size}`);
            
            // Find all non-accessible regions that aren't walls
            const filledRegions = [];
            const processed = new Set();
            
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    
                    // Skip if already processed or accessible or already permanently filled
                    if (processed.has(key) || ballAccessible.has(key) || game.permanentlyFilled.has(key)) continue;
                    
                    const cellMinX = col * GRID_SIZE;
                    const cellMaxX = (col + 1) * GRID_SIZE;
                    const cellMinY = row * GRID_SIZE;
                    const cellMaxY = (row + 1) * GRID_SIZE;
                    
                    // Check if this cell intersects with a wall
                    let blockedByWall = false;
                    for (let wall of game.completedWalls) {
                        const bounds = wall.bounds;
                        if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                              cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                            blockedByWall = true;
                            break;
                        }
                    }
                    
                    if (!blockedByWall) {
                        // Found a filled cell - gather the entire region
                        const region = [];
                        const stack = [[col, row]];
                        const regionSet = new Set();
                        
                        while (stack.length > 0) {
                            const [c, r] = stack.pop();
                            const k = `${c},${r}`;
                            
                            if (c < 0 || c >= GRID_COLS || r < 0 || r >= GRID_ROWS) continue;
                            if (regionSet.has(k) || ballAccessible.has(k) || processed.has(k)) continue;
                            
                            const cellMinX = c * GRID_SIZE;
                            const cellMaxX = (c + 1) * GRID_SIZE;
                            const cellMinY = r * GRID_SIZE;
                            const cellMaxY = (r + 1) * GRID_SIZE;
                            
                            // Check if cell intersects with a wall
                            let blockedByWall = false;
                            for (let wall of game.completedWalls) {
                                const bounds = wall.bounds;
                                if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                                      cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                                    blockedByWall = true;
                                    break;
                                }
                            }
                            
                            if (blockedByWall) {
                                processed.add(k);
                                continue;
                            }
                            
                            regionSet.add(k);
                            processed.add(k);
                            region.push([c, r]);
                            
                            stack.push([c + 1, r], [c - 1, r], [c, r + 1], [c, r - 1]);
                        }
                        
                        if (region.length > 5) {
                            filledRegions.push(region);
                        }
                    } else {
                        processed.add(key);
                    }
                }
            }
            
            console.log(`Found ${filledRegions.length} filled regions`);
            
            // Check for Ball Destruction unlock (3+ balls in small box)
            if (!game.powerupsUnlocked[2]) {
                const totalArea = GRID_COLS * GRID_ROWS;
                filledRegions.forEach((region) => {
                    const regionArea = region.length;
                    const areaPercent = (regionArea / totalArea) * 100;
                    
                    // Count balls that would be in this region
                    let ballsInRegion = 0;
                    game.balls.forEach(ball => {
                        const pos = ball.body.position;
                        const col = Math.floor(pos.x / GRID_SIZE);
                        const row = Math.floor(pos.y / GRID_SIZE);
                        const key = `${col},${row}`;
                        
                        // Check if ball is in this region
                        if (region.some(([c, r]) => `${c},${r}` === key)) {
                            ballsInRegion++;
                        }
                    });
                    
                    // Unlock if 3+ balls in a box that's ‚â§20% of total area
                    if (ballsInRegion >= 3 && areaPercent <= 20) {
                        game.powerupsUnlocked[2] = true;
                        setTimeout(() => {
                            showMessage('üéä UNLOCKED: üí• Ball Destruction!');
                            updatePowerupUI();
                        }, 3000);
                    }
                });
            }
            
            // Create falling animation for each filled region
            filledRegions.forEach((region, idx) => {
                console.log(`Region ${idx}: ${region.length} cells`);
                const minCol = Math.min(...region.map(([c, r]) => c));
                const maxCol = Math.max(...region.map(([c, r]) => c));
                const minRow = Math.min(...region.map(([c, r]) => r));
                const maxRow = Math.max(...region.map(([c, r]) => r));
                console.log(`  Bounds: cols ${minCol}-${maxCol}, rows ${minRow}-${maxRow}`);
                
                // Check for hidden walls in this region (no balls in region = safe)
                let foundHiddenWalls = 0;
                region.forEach(([c, r]) => {
                    game.hiddenWalls.forEach(hw => {
                        if (!hw.collected && hw.col === c && hw.row === r) {
                            hw.collected = true;
                            foundHiddenWalls++;
                        }
                    });
                });
                
                if (foundHiddenWalls > 0) {
                    game.wallsLeft += foundHiddenWalls;
                    showMessage(`‚ú® Found ${foundHiddenWalls} hidden wall${foundHiddenWalls > 1 ? 's' : ''}! +${foundHiddenWalls} wall${foundHiddenWalls > 1 ? 's' : ''}`);
                    updateUI();
                }
                
                // Mark all cells in this region as permanently filled
                region.forEach(([c, r]) => {
                    game.permanentlyFilled.add(`${c},${r}`);
                });
                
                game.fallingSections.push({
                    x: minCol * GRID_SIZE,
                    y: minRow * GRID_SIZE,
                    width: (maxCol - minCol + 1) * GRID_SIZE,
                    height: (maxRow - minRow + 1) * GRID_SIZE,
                    scale: 1,
                    opacity: 1,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    cells: region
                });
            });
        }
        
        function updateFallingSections() {
            game.fallingSections = game.fallingSections.filter(section => {
                section.scale -= 0.025;
                section.rotation += section.rotationSpeed;
                section.opacity -= 0.025;
                section.y += 3; // Fall downward
                return section.scale > 0 && section.opacity > 0;
            });
        }
        
        function updateBallSpeeds() {
            const totalArea = GRID_COLS * GRID_ROWS;
            
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                
                // Calculate accessible area for this ball
                const accessible = new Set();
                floodFill(col, row, accessible);
                const ballArea = accessible.size;
                
                // Speed increases gradually as area decreases
                // Uses squared formula for gentle start, stronger acceleration at small areas
                const areaRatio = Math.max(ballArea / totalArea, 0.01);
                const reduction = 1 - areaRatio; // How much area is gone (0 to 1)
                const speedMultiplier = 1 + (reduction * reduction * 3); // Max ~4x at very small areas
                
                // Update ball speed
                ball.speed = ball.baseSpeed * speedMultiplier;
                
                // Adjust velocity to match new speed while maintaining direction
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (currentSpeed > 0.1) {
                    const ratio = ball.speed / currentSpeed;
                    ball.vx *= ratio;
                    ball.vy *= ratio;
                }
            });
        }
        
        function updateCompletedWalls() {
            // Check for double-hits on completed walls
            game.completedWalls = game.completedWalls.filter(wall => {
                // Check if any ball is colliding with this wall
                let hitBall = null;
                for (let ball of game.balls) {
                    const pos = ball.body.position;
                    const radius = ball.body.circleRadius;
                    const bounds = wall.bounds;
                    if (pos.x + radius > bounds.min.x && pos.x - radius < bounds.max.x &&
                        pos.y + radius > bounds.min.y && pos.y - radius < bounds.max.y) {
                        hitBall = ball;
                        break;
                    }
                }
                
                if (hitBall) {
                    // Track which ball hit and the time for wall destruction logic
                    if (!wall.firstHitTime) {
                        wall.firstHitTime = Date.now();
                        wall.firstHitBall = hitBall;
                    } else if (Date.now() - wall.firstHitTime < 200 && wall.firstHitBall !== hitBall) {
                        // Two hits within 200ms by DIFFERENT balls - destroy wall
                        createShatterEffect({
                            x: wall.bounds.min.x,
                            y: wall.bounds.min.y,
                            width: wall.bounds.max.x - wall.bounds.min.x,
                            height: wall.bounds.max.y - wall.bounds.min.y
                        });
                        
                        // Remove wall from physics world
                        World.remove(world, wall);
                        
                        // Clear cells from permanentlyFilled
                        const bounds = wall.bounds;
                        for (let x = Math.floor(bounds.min.x / GRID_SIZE); x < Math.ceil(bounds.max.x / GRID_SIZE); x++) {
                            for (let y = Math.floor(bounds.min.y / GRID_SIZE); y < Math.ceil(bounds.max.y / GRID_SIZE); y++) {
                                game.permanentlyFilled.delete(`${x},${y}`);
                            }
                        }
                        
                        if (game.gameMode === 'survival') {
                            game.wallsLeft++; // Refund the wall in Survival mode
                        }
                        showMessage('üí• Completed wall destroyed by double hit!');
                        updateUI();
                        return false; // Remove from array
                    }
                } else {
                    // Reset hit tracking if no ball is touching
                    wall.firstHitTime = null;
                    wall.firstHitBall = null;
                }
                
                return true; // Keep wall
            });
        }
        
        function updateBallPhysics() {
            // Don't update ball physics if frozen
            if (game.freezeTimeActive) return;
            
            // Apply slow motion multiplier if active
            const speedMultiplier = game.slowMotionActive ? 0.5 : 1.0;
            
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                // Simple movement (with speed multiplier)
                let x = pos.x + ball.vx * speedMultiplier;
                let y = pos.y + ball.vy * speedMultiplier;
                
                // Boundary collisions with reflection
                if (x - radius < 0) {
                    x = radius;
                    ball.vx = Math.abs(ball.vx);
                } else if (x + radius > canvas.width) {
                    x = canvas.width - radius;
                    ball.vx = -Math.abs(ball.vx);
                }
                
                if (y - radius < 0) {
                    y = radius;
                    ball.vy = Math.abs(ball.vy);
                } else if (y + radius > canvas.height) {
                    y = canvas.height - radius;
                    ball.vy = -Math.abs(ball.vy);
                }
                
                // Ball-to-ball collisions (with limited separation to prevent escaping)
                for (let j = 0; j < game.balls.length; j++) {
                    const otherBall = game.balls[j];
                    if (otherBall === ball) continue;
                    
                    const otherPos = otherBall.body.position;
                    const dx = x - otherPos.x;
                    const dy = y - otherPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = radius * 2;
                    
                    if (distance < minDist && distance > 0.1) {
                        // Only create effect once per collision pair (use index to avoid duplicates)
                        if (!ball.collisionCooldown && j > game.balls.indexOf(ball)) {
                            const collisionX = (x + otherPos.x) / 2;
                            const collisionY = (y + otherPos.y) / 2;
                            createCollisionEffect(collisionX, collisionY, ball.color, otherBall.color);
                            ball.collisionCooldown = true;
                            otherBall.collisionCooldown = true;
                            setTimeout(() => {
                                ball.collisionCooldown = false;
                                otherBall.collisionCooldown = false;
                            }, 150);
                        }
                        
                        // Separate balls with limited displacement
                        const overlap = minDist - distance;
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const separation = Math.min(overlap / 2, 2); // Limit separation to 2 pixels max
                        x += nx * separation;
                        y += ny * separation;
                        
                        // Elastic collision response
                        const dvx = ball.vx - otherBall.vx;
                        const dvy = ball.vy - otherBall.vy;
                        const dotProduct = dvx * nx + dvy * ny;
                        
                        if (dotProduct < 0) {
                            ball.vx -= dotProduct * nx;
                            ball.vy -= dotProduct * ny;
                        }
                    }
                }
                
                // Clamp to boundaries after ball collision (prevent escaping)
                x = Math.max(radius, Math.min(canvas.width - radius, x));
                y = Math.max(radius, Math.min(canvas.height - radius, y));
                
                // Wall collisions - simple overlap check
                for (const wall of game.completedWalls) {
                    const bounds = wall.bounds;
                    const wallWidth = bounds.max.x - bounds.min.x;
                    const wallHeight = bounds.max.y - bounds.min.y;
                    
                    // Check if ball overlaps wall
                    if (x + radius > bounds.min.x && x - radius < bounds.max.x &&
                        y + radius > bounds.min.y && y - radius < bounds.max.y) {
                        
                        // Mark wall as hit
                        wall.hitTime = Date.now();
                        
                        // Determine wall orientation and reflect
                        if (wallWidth > wallHeight) {
                            // Horizontal wall
                            if (ball.vy > 0) {
                                y = bounds.min.y - radius;
                            } else {
                                y = bounds.max.y + radius;
                            }
                            ball.vy = -ball.vy;
                        } else {
                            // Vertical wall
                            if (ball.vx > 0) {
                                x = bounds.min.x - radius;
                            } else {
                                x = bounds.max.x + radius;
                            }
                            ball.vx = -ball.vx;
                        }
                    }
                }
                
                // Maintain constant speed
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (currentSpeed > 0) {
                    ball.vx = (ball.vx / currentSpeed) * ball.speed;
                    ball.vy = (ball.vy / currentSpeed) * ball.speed;
                }
                
                // Update position
                Body.setPosition(ball.body, { x, y });
            });
        }
        
        function mixColors(color1, color2) {
            // Convert hex colors to RGB and mix them
            const hex1 = color1.replace('#', '');
            const hex2 = color2.replace('#', '');
            
            const r1 = parseInt(hex1.substr(0, 2), 16);
            const g1 = parseInt(hex1.substr(2, 2), 16);
            const b1 = parseInt(hex1.substr(4, 2), 16);
            
            const r2 = parseInt(hex2.substr(0, 2), 16);
            const g2 = parseInt(hex2.substr(2, 2), 16);
            const b2 = parseInt(hex2.substr(4, 2), 16);
            
            const r = Math.round((r1 + r2) / 2);
            const g = Math.round((g1 + g2) / 2);
            const b = Math.round((b1 + b2) / 2);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        function createCollisionEffect(x, y, color1, color2) {
            // Create sparkle particles at collision point
            const particleCount = 6; // Reduced from 12
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                game.collisionEffects.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.8, // Reduced from 1.0
                    color: i % 2 === 0 ? color1 : color2,
                    size: 3 + Math.random() * 2
                });
            }
            
            // Add a bright flash at the center (mixed color)
            const mixedColor = mixColors(color1, color2);
            game.collisionEffects.push({
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                life: 0.6, // Reduced from 1.0
                color: mixedColor,
                size: 12, // Reduced from 15
                isFlash: true
            });
        }
        
        function updateCollisionEffects() {
            game.collisionEffects = game.collisionEffects.filter(effect => {
                effect.x += effect.vx;
                effect.y += effect.vy;
                effect.life -= 0.08; // Faster decay
                effect.size *= 0.92; // Faster shrink
                return effect.life > 0;
            });
        }
        
        function createShatterEffect(wall) {
            // Create particles from the wall
            const particleCount = 20;
            const centerX = wall.x + wall.width / 2;
            const centerY = wall.y + wall.height / 2;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                game.shatterEffects.push({
                    x: centerX + (Math.random() - 0.5) * wall.width,
                    y: centerY + (Math.random() - 0.5) * wall.height,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 4,
                    life: 1.0,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }
        
        function updateShatterEffects() {
            game.shatterEffects = game.shatterEffects.filter(effect => {
                effect.x += effect.vx;
                effect.y += effect.vy;
                effect.vy += 0.3; // Gravity
                effect.rotation += effect.rotationSpeed;
                effect.life -= 0.02;
                return effect.life > 0;
            });
        }
        
        function updateBallTrails() {
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                ball.trail.push({ x: pos.x, y: pos.y });
                
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const maxTrailLength = Math.floor(8 + speed * 2); // Shorter trails for better performance
                
                if (ball.trail.length > maxTrailLength) {
                    ball.trail.shift();
                }
            });
        }
        
        function floodFill(startCol, startRow, visited) {
            const stack = [[startCol, startRow]];
            
            while (stack.length > 0) {
                const [col, row] = stack.pop();
                
                if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) continue;
                
                const key = `${col},${row}`;
                if (visited.has(key)) continue;
                
                // Check if this grid cell intersects with any wall
                const cellMinX = col * GRID_SIZE;
                const cellMaxX = (col + 1) * GRID_SIZE;
                const cellMinY = row * GRID_SIZE;
                const cellMaxY = (row + 1) * GRID_SIZE;
                
                let blockedByWall = false;
                for (let wall of game.completedWalls) {
                    const bounds = wall.bounds;
                    // Check if cell area intersects with wall bounds
                    if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                          cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                        blockedByWall = true;
                        break;
                    }
                }
                
                if (blockedByWall) continue;
                
                visited.add(key);
                
                stack.push([col + 1, row], [col - 1, row], [col, row + 1], [col, row - 1]);
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a0a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw filled areas
            const accessible = new Set();
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            // Draw filled areas in one pass
            ctx.fillStyle = '#2d1b4e';
            ctx.beginPath();
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    if (!accessible.has(key)) {
                        ctx.rect(col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            ctx.fill()
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(147, 51, 234, 0.15)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
            
            // Draw completed walls
            game.completedWalls.forEach(wall => {
                const bounds = wall.bounds;
                const now = Date.now();
                const timeSinceHit = wall.hitTime ? now - wall.hitTime : 9999;
                const blinkDuration = 200; // milliseconds
                
                // Determine color based on hit time
                if (timeSinceHit < blinkDuration) {
                    const progress = timeSinceHit / blinkDuration;
                    ctx.fillStyle = '#10b981'; // Green
                    ctx.shadowColor = '#10b981';
                    ctx.shadowBlur = 15 * (1 - progress); // Fade shadow
                } else {
                    ctx.fillStyle = '#9333ea'; // Purple
                    ctx.shadowColor = '#9333ea';
                    ctx.shadowBlur = 10;
                }
                
                ctx.fillRect(
                    bounds.min.x,
                    bounds.min.y,
                    bounds.max.x - bounds.min.x,
                    bounds.max.y - bounds.min.y
                );
            });
            
            // Draw building walls
            ctx.fillStyle = '#ec4899';
            ctx.shadowColor = '#ec4899';
            game.buildingWalls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });
            
            ctx.shadowBlur = 0;
            
            // Draw falling sections
            game.fallingSections.forEach((section, idx) => {
                ctx.save();
                ctx.globalAlpha = section.opacity;
                ctx.translate(section.x + section.width / 2, section.y + section.height / 2);
                ctx.rotate(section.rotation);
                ctx.scale(section.scale, section.scale);
                
                // Create gradient for falling sections
                const gradient = ctx.createLinearGradient(
                    -section.width / 2, -section.height / 2,
                    section.width / 2, section.height / 2
                );
                gradient.addColorStop(0, '#ec4899');
                gradient.addColorStop(0.5, '#9333ea');
                gradient.addColorStop(1, '#3b82f6');
                
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ec4899';
                ctx.fillRect(-section.width / 2, -section.height / 2, section.width, section.height);
                
                ctx.restore();
            });
            
            // Draw ball tracers
            game.balls.forEach(ball => {
                if (ball.trail.length > 1) {
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    for (let i = 1; i < ball.trail.length; i++) {
                        const progress = i / ball.trail.length;
                        const alpha = progress * 0.4;
                        
                        // Draw outer glow (wider, more intense)
                        ctx.strokeStyle = ball.color;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.lineWidth = 12;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = ball.color;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                        
                        // Draw bright core (wider, brighter)
                        ctx.globalAlpha = alpha * 0.6;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                        
                        // Add extra bright center line
                        ctx.globalAlpha = alpha * 0.7;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            });
            
            // Draw collision effects
            game.collisionEffects.forEach(effect => {
                ctx.save();
                ctx.globalAlpha = effect.life;
                
                if (effect.isFlash) {
                    // Bright flash at center
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = effect.color;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Sparkle particles
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = effect.color;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add white core to sparkles
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
            
            // Draw shatter effects
            game.shatterEffects.forEach(effect => {
                ctx.save();
                ctx.globalAlpha = effect.life;
                ctx.translate(effect.x, effect.y);
                ctx.rotate(effect.rotation);
                
                // Green shard with glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#4ade80';
                ctx.fillStyle = '#4ade80';
                ctx.fillRect(-effect.size/2, -effect.size/2, effect.size, effect.size);
                
                ctx.restore();
            });
            
            // Draw balls
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = ball.color;
                
                const grad = ctx.createRadialGradient(
                    pos.x - radius * 0.3, pos.y - radius * 0.3, radius * 0.1,
                    pos.x, pos.y, radius
                );
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.3, ball.color);
                grad.addColorStop(1, darkenColor(ball.color, 0.4));
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Rim light
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 0;
                ctx.stroke();
                
                // Highlight shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(pos.x - radius * 0.35, pos.y - radius * 0.35, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Draw cursor direction indicator and crosshair
            if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height && 
                game.isRunning && !game.isPaused) {
                ctx.save();
                
                // Direction line (only when not building)
                if (!game.buildingWall) {
                    ctx.strokeStyle = 'rgba(236, 72, 153, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ec4899';
                    
                    ctx.beginPath();
                    if (wallDirection === 'horizontal') {
                        ctx.moveTo(0, mouseY);
                        ctx.lineTo(canvas.width, mouseY);
                    } else {
                        ctx.moveTo(mouseX, 0);
                        ctx.lineTo(mouseX, canvas.height);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Crosshair
                ctx.strokeStyle = '#ec4899';
                ctx.fillStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ec4899';
                
                ctx.beginPath();
                ctx.moveTo(mouseX - 10, mouseY);
                ctx.lineTo(mouseX - 3, mouseY);
                ctx.moveTo(mouseX + 3, mouseY);
                ctx.lineTo(mouseX + 10, mouseY);
                ctx.moveTo(mouseX, mouseY - 10);
                ctx.lineTo(mouseX, mouseY - 3);
                ctx.moveTo(mouseX, mouseY + 3);
                ctx.lineTo(mouseX, mouseY + 10);
                ctx.stroke();
                
                // Center dot
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function darkenColor(color, factor) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function gameLoop() {
            if (!game.isRunning) return;
            
            if (!game.isPaused) {
                // Time Attack mode - decrease timer
                if (game.gameMode === 'timeattack' && game.timeRemaining > 0) {
                    game.timeRemaining -= 1/60; // Decrease by 1/60th second per frame (assuming 60fps)
                    if (game.timeRemaining <= 0) {
                        game.timeRemaining = 0;
                        gameOver();
                        return;
                    }
                }
                
                updateBallSpeeds();
                updateBallPhysics();
                updateBuildingWall();
                updateCompletedWalls();
                updateFallingSections();
                updateBallTrails();
                updateCollisionEffects();
                updateShatterEffects();
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function levelComplete() {
            game.isRunning = false;
            game.levelsCompleted++;
            
            const completionTime = (Date.now() - game.levelStartTime) / 1000; // seconds
            const filledPercent = calculateFilledPercent();
            
            // Time Attack mode - add bonus time for quick completion
            if (game.gameMode === 'timeattack') {
                const bonusTime = Math.max(0, 30 - completionTime); // Up to 30 seconds bonus
                game.timeRemaining += bonusTime;
                if (bonusTime > 0) {
                    showMessage(`Level ${game.level} Complete! +${bonusTime.toFixed(1)}s bonus time!`);
                } else {
                    showMessage(`Level ${game.level} Complete!`);
                }
            } else {
                // Check unlock conditions
                checkUnlockConditions(completionTime, filledPercent);
                
                // +1 wall every 5 levels
                if (game.levelsCompleted % 5 === 0) {
                    showMessage(`Level ${game.level} Complete! üéâ Bonus: +1 Wall for reaching level ${game.levelsCompleted}!`);
                } else {
                    showMessage(`Level ${game.level} Complete!`);
                }
            }
            
            setTimeout(() => {
                if (game.levelsCompleted % 5 === 0 && game.gameMode !== 'timeattack') {
                    game.lives++; // Give +1 wall (lives = walls)
                    updateUI();
                }
                game.level++;
                game.isRunning = true;
                initLevel();
                gameLoop();
            }, 2000);
        }
        
        function checkUnlockConditions(completionTime, filledPercent) {
            const unlocked = [];
            
            // 0: Freeze Time - Zero walls lost AND level 3+ AND 80%+ filled
            if (!game.powerupsUnlocked[0] && game.wallsLostThisLevel === 0 && game.level >= 3 && filledPercent >= 80) {
                game.powerupsUnlocked[0] = true;
                unlocked.push('‚ùÑÔ∏è Freeze Time');
            }
            
            // 1: Electron Beam - Complete level very quickly (harder threshold)
            const timeThreshold = 15 + game.level * 5; // Level 1: 20s, Level 2: 25s, etc. (much faster required)
            if (!game.powerupsUnlocked[1] && completionTime < timeThreshold && game.level >= 2) {
                game.powerupsUnlocked[1] = true;
                unlocked.push('‚ö° Electron Beam');
            }
            
            // 4: Slow Motion - 85%+ filled (increased from 75%)
            if (!game.powerupsUnlocked[4] && filledPercent >= 85) {
                game.powerupsUnlocked[4] = true;
                unlocked.push('‚è±Ô∏è Slow Motion');
            }
            
            // 3: Bounce Update - 10+ walls placed (increased from 7)
            if (!game.powerupsUnlocked[3] && game.wallsPlacedThisLevel >= 10) {
                game.powerupsUnlocked[3] = true;
                unlocked.push('üîÑ Bounce Update');
            }
            
            // 6: Second Chance - Flawless Victory (90%+ filled AND zero walls lost AND level 5+)
            if (!game.powerupsUnlocked[6] && filledPercent >= 90 && game.wallsLostThisLevel === 0 && game.level >= 5) {
                game.powerupsUnlocked[6] = true;
                unlocked.push('üîÑüí´ SECOND CHANCE');
            }
            
            // 2: Ball Destruction - checked in createFallingSections when balls are trapped
            
            if (unlocked.length > 0) {
                setTimeout(() => {
                    showMessage(`üéä UNLOCKED: ${unlocked.join(', ')}!`);
                    updatePowerupUI();
                }, 2500);
            }
        }
        
        function gameOver() {
            game.isRunning = false;
            
            // Mode-specific game over messages
            let gameOverMessage = 'üíÄ Game Over!';
            if (game.gameMode === 'timeattack') {
                gameOverMessage += '\n‚è±Ô∏è Time ran out!';
            } else if (game.gameMode === 'survival') {
                gameOverMessage += '\nüí• Out of walls or lives!';
            } else {
                gameOverMessage += '\nüíî Out of lives!';
            }
            
            // Check if Second Chance is available (not available in Free Play mode)
            if (game.gameMode !== 'freeplay' && game.powerupsUnlocked[6] && !game.powerupsUsed[6]) {
                // Offer Second Chance
                const useSecondChance = confirm(`${gameOverMessage}\n\nüîÑüí´ You have a Second Chance available!\n\nUse it to restore your lives and restart this level?\n\n(This will consume your Second Chance power-up)`);
                
                if (useSecondChance) {
                    // Use Second Chance
                    game.powerupsUsed[6] = true;
                    game.lives = 5 + game.level * 2; // Full refill
                    
                    // In Time Attack mode, also add bonus time
                    if (game.gameMode === 'timeattack') {
                        game.timeRemaining += 30;
                    }
                    
                    game.isRunning = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('üîÑüí´ Second Chance activated! Lives restored!');
                    initLevel(); // Restart level
                    return;
                }
            } else if (game.gameMode === 'freeplay') {
                // Free Play mode - offer unlimited continues
                const continueGame = confirm(`${gameOverMessage}\n\nüéÆ Free Play Mode: Continue playing?\n\n(You can restart this level as many times as you want!)`);
                
                if (continueGame) {
                    game.lives = 5;
                    game.isRunning = true;
                    updateUI();
                    showMessage('üéÆ Continuing in Free Play mode!');
                    initLevel(); // Restart level
                    return;
                }
            }
            
            // No Second Chance or declined - reset power-up usage
            game.powerupsUsed = [false, false, false, false, false, false, false];
            updatePowerupUI();
            
            // Final game over message
            if (game.gameMode === 'freeplay') {
                showMessage('Thanks for playing! Reload to start again.');
            } else {
                showMessage(`Game Over! Reached Level ${game.level}. Reload to play again.`);
            }
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseX = -100;
            mouseY = -100;
        });
        
        canvas.addEventListener('click', e => {
            // In Survival mode, check wallsLeft. In other modes, unlimited walls.
            if (!game.isRunning || game.isPaused || (game.gameMode === 'survival' && game.wallsLeft <= 0)) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if click is in a fallen area
            const col = Math.floor(x / GRID_SIZE);
            const row = Math.floor(y / GRID_SIZE);
            const key = `${col},${row}`;
            
            if (game.permanentlyFilled.has(key)) {
                showMessage('Cannot place wall in fallen area!');
                return;
            }
            
            // Electron Beam mode - indestructible wall that builds normally but can't be stopped
            if (game.electronBeamActive) {
                // Only decrease wallsLeft in Survival mode
                if (game.gameMode === 'survival') {
                    game.wallsLeft--;
                }
                updateUI();
                
                if (wallDirection === 'horizontal') {
                    game.buildingWalls.push({
                        x: x,
                        y: y - WALL_THICKNESS / 2,
                        width: 0,
                        height: WALL_THICKNESS,
                        direction: 'horizontal',
                        isElectronBeam: true // Mark as indestructible
                    });
                } else {
                    game.buildingWalls.push({
                        x: x - WALL_THICKNESS / 2,
                        y: y,
                        width: WALL_THICKNESS,
                        height: 0,
                        direction: 'vertical',
                        isElectronBeam: true // Mark as indestructible
                    });
                }
                
                // Deactivate after use
                game.electronBeamActive = false;
                showMessage('‚ö° Electron Beam wall building - indestructible!');
                return;
            }
            
            // Only decrease wallsLeft in Survival mode
            if (game.gameMode === 'survival') {
                game.wallsLeft--;
            }
            updateUI();
            
            if (wallDirection === 'horizontal') {
                game.buildingWalls.push({
                    x: x,
                    y: y - WALL_THICKNESS / 2,
                    width: 0,
                    height: WALL_THICKNESS,
                    direction: 'horizontal'
                });
            } else {
                game.buildingWalls.push({
                    x: x - WALL_THICKNESS / 2,
                    y: y,
                    width: WALL_THICKNESS,
                    height: 0,
                    direction: 'vertical'
                });
            }
        });
        
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
            updateUI();
        });
        
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
                updateUI();
            }
        });
        
        // Power-up controls
        const powerupItems = document.querySelectorAll('.powerup-item');
        
        document.addEventListener('wheel', e => {
            e.preventDefault(); // Prevent page scrolling
            if (e.deltaY > 0) {
                game.selectedPowerup = (game.selectedPowerup + 1) % powerupItems.length;
            } else {
                game.selectedPowerup = (game.selectedPowerup - 1 + powerupItems.length) % powerupItems.length;
            }
            updatePowerupUI();
        }, { passive: false }); // Allow preventDefault to work
        
        document.addEventListener('mousedown', e => {
            if (e.button === 1) {
                e.preventDefault();
                activatePowerup(game.selectedPowerup);
            }
        });
        
        function updatePowerupUI() {
            powerupItems.forEach((item, index) => {
                item.classList.remove('selected');
                if (index === game.selectedPowerup) {
                    item.classList.add('selected');
                }
                
                // Update status text
                const statusEl = item.querySelector('.powerup-status');
                if (!game.powerupsUnlocked[index]) {
                    statusEl.textContent = 'Locked';
                    statusEl.style.color = '#666';
                } else if (game.powerupsUsed[index]) {
                    statusEl.textContent = 'Used';
                    statusEl.style.color = '#888';
                } else {
                    statusEl.textContent = 'Ready';
                    statusEl.style.color = '#10b981';
                }
            });
        }
        
        function activatePowerup(index) {
            if (!game.isRunning) {
                showMessage('Start the game first!');
                return;
            }
            
            if (!game.powerupsUnlocked[index]) {
                showMessage('Power-up is locked!');
                return;
            }
            
            if (game.powerupsUsed[index]) {
                showMessage('Power-up already used!');
                return;
            }
            
            const powerupNames = ['Freeze Time', 'Electron Beam', 'Ball Destruction', 'Bounce Update', 'Slow Motion', 'Extra Wall', 'Second Chance'];
            
            // Implement power-ups
            switch(index) {
                case 0: // Freeze Time - Pause balls for 5 seconds
                    game.freezeTimeActive = true;
                    game.powerupsUsed[index] = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('‚ùÑÔ∏è Freeze Time! Balls frozen for 5 seconds!');
                    setTimeout(() => {
                        game.freezeTimeActive = false;
                        showMessage('Balls unfrozen!');
                    }, 5000);
                    break;
                    
                case 1: // Electron Beam - Next wall is instant (no growth, just click-to-click)
                    game.electronBeamActive = true;
                    game.powerupsUsed[index] = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('‚ö° Electron Beam! Click start and end points for instant wall!');
                    break;
                    
                case 2: // Ball Destruction - Remove one ball
                    if (game.balls.length > 0) {
                        const removedBall = game.balls.pop();
                        World.remove(world, removedBall.body);
                        game.powerupsUsed[index] = true;
                        updateUI();
                        updatePowerupUI();
                        showMessage('üí• Ball Destroyed! -1 Ball');
                    } else {
                        showMessage('No balls to destroy!');
                    }
                    break;
                    
                case 3: // Bounce Update - Randomize all ball directions
                    game.balls.forEach(ball => {
                        const angle = Math.random() * Math.PI * 2;
                        ball.vx = Math.cos(angle) * ball.speed;
                        ball.vy = Math.sin(angle) * ball.speed;
                    });
                    game.powerupsUsed[index] = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('üîÑ Bounce Update! All ball directions randomized!');
                    break;
                    
                case 4: // Slow Motion - Half speed for 10 seconds
                    game.slowMotionActive = true;
                    game.slowMotionEndTime = Date.now() + 10000;
                    game.powerupsUsed[index] = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('‚è±Ô∏è Slow Motion! Balls slowed for 10 seconds!');
                    setTimeout(() => {
                        game.slowMotionActive = false;
                        showMessage('Normal speed resumed!');
                    }, 10000);
                    break;
                    
                case 5: // Extra Wall
                    game.wallsLeft++;
                    game.powerupsUsed[index] = true;
                    updateUI();
                    updatePowerupUI();
                    showMessage('‚ûï Extra Wall! +1 Wall');
                    break;
                    
                case 6: // Second Chance (reset level with full lives)
                    game.powerupsUsed[index] = true;
                    game.lives = 5 + game.level * 2; // Full refill
                    updateUI();
                    updatePowerupUI();
                    showMessage('üîÑüí´ Second Chance! Lives restored!');
                    initLevel(); // Restart level
                    break;
            }
        }
        
        updatePowerupUI();
        
        document.getElementById('startBtn').addEventListener('click', () => {
            game.level = 1;
            game.lives = 5;
            game.isRunning = true;
            game.isPaused = false;
            game.levelsCompleted = 0;
            // Reset power-up usage (but keep unlocks)
            game.powerupsUsed = [false, false, false, false, false, false, false];
            updatePowerupUI();
            initLevel();
            gameLoop();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            game.isPaused = !game.isPaused;
            document.getElementById('pauseBtn').textContent = game.isPaused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (game.isRunning) {
                initLevel();
            }
        });
        
        draw();
    </script>
</body>
</html>
