<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jezzball - Retro Arcade</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', cursive;
            background-image: url('../../assets/background.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        .back-button-top {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(147, 51, 234, 0.4);
        }
        .back-button-top:hover {
            transform: translateY(-2px);
        }
        .game-container {
            background: linear-gradient(145deg, rgba(30, 20, 60, 0.95), rgba(50, 30, 80, 0.95));
            border: 4px solid #9333ea;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.4);
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 rgba(147, 51, 234, 0.8);
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(26, 15, 46, 0.8);
            border: 2px solid #4a148c;
            flex-wrap: wrap;
            gap: 15px;
        }
        .info-item {
            color: #9333ea;
            font-size: 10px;
        }
        .info-value {
            color: #ec4899;
            margin-left: 5px;
        }
        #gameCanvas {
            display: block;
            background: #0a0515;
            border: 4px solid #4a148c;
            margin: 0 auto 15px;
            cursor: none;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 12px 20px;
            background: linear-gradient(180deg, #9333ea 0%, #6b21a8 100%);
            border: 3px solid #4a148c;
            color: white;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        button:hover { transform: translateY(-2px); }
        .back-button { display: none; }
        .message {
            text-align: center;
            color: #ec4899;
            font-size: 12px;
            margin-bottom: 10px;
            line-height: 1.8;
            min-height: 40px;
        }
        .powerup-container {
            background: rgba(26, 15, 46, 0.6);
            border: 2px solid #4a148c;
            border-radius: 10px;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 700px;
            margin-bottom: 15px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }
        .powerup-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(10, 5, 21, 0.8);
            border: 2px solid transparent;
            border-radius: 5px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .powerup-item.selected {
            border-color: #ec4899;
            background: rgba(236, 72, 153, 0.2);
            box-shadow: 0 0 10px rgba(236, 72, 153, 0.3);
        }
        .powerup-item.active {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
            animation: pulse 1s infinite;
        }
        .powerup-icon {
            font-size: 14px;
            min-width: 20px;
        }
        .powerup-name {
            flex: 1;
            color: #9333ea;
            font-size: 7px;
            line-height: 1.2;
        }
        .powerup-status {
            color: #ec4899;
            font-size: 6px;
        }
        .powerup-help {
            grid-column: 1 / -1;
            text-align: center;
            color: #6b21a8;
            font-size: 7px;
            padding-top: 5px;
            border-top: 1px solid #4a148c;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <button class="back-button-top" onclick="window.location.href='../games.html'">‚Üê Back</button>
    
    <div class="game-container">
        <h1>Jezzball</h1>
        <div class="game-info">
            <div class="info-item">Level: <span class="info-value" id="level">1</span></div>
            <div class="info-item">Lives: <span class="info-value" id="lives">5</span></div>
            <div class="info-item">Walls: <span class="info-value" id="walls">7</span></div>
            <div class="info-item">Filled: <span class="info-value" id="filled">0%</span></div>
            <div class="info-item">Goal: <span class="info-value" id="goal">75%</span></div>
            <div class="info-item">Direction: <span class="info-value" id="direction">Horizontal</span></div>
        </div>
        <div class="message" id="message">Click to build walls! Right-click or SPACE to switch direction!</div>
        
        <!-- Power-up Display -->
        <div class="powerup-container">
            <div class="powerup-item selected" data-powerup="0">
                <div class="powerup-icon">‚ùÑÔ∏è</div>
                <div class="powerup-name">Freeze Time</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="1">
                <div class="powerup-icon">‚ö°</div>
                <div class="powerup-name">Electron Beam</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="2">
                <div class="powerup-icon">üí•</div>
                <div class="powerup-name">Ball Destruction</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="3">
                <div class="powerup-icon">üîÑ</div>
                <div class="powerup-name">Bounce Update</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="4">
                <div class="powerup-icon">‚è±Ô∏è</div>
                <div class="powerup-name">Slow Motion</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-item" data-powerup="5">
                <div class="powerup-icon">‚ù§Ô∏è</div>
                <div class="powerup-name">Extra Life</div>
                <div class="powerup-status">Locked</div>
            </div>
            <div class="powerup-help">Scroll: Select | Middle Click: Activate</div>
        </div>
        
        <canvas id="gameCanvas" width="700" height="500"></canvas>
        <div class="controls">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn">Pause</button>
            <button id="restartBtn">Restart Level</button>
        </div>
    </div>

    <script>
        const { Engine, World, Bodies, Body, Events, Composite } = Matter;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Physics engine setup with optimized settings for bouncing
        const engine = Engine.create({ 
            gravity: { x: 0, y: 0 },
            enableSleeping: false,
            positionIterations: 10,
            velocityIterations: 8,
            constraintIterations: 4
        });
        engine.timing.timeScale = 1;
        const world = engine.world;
        
        let game = {
            level: 1,
            lives: 5,
            wallsLeft: 7,
            balls: [],
            completedWalls: [],
            buildingWalls: [], // Changed to array for multiple simultaneous walls
            isRunning: false,
            isPaused: false,
            goalPercent: 75,
            fallingSections: [],
            selectedPowerup: 0,
            activePowerups: [],
            permanentlyFilled: new Set(), // Track cells that have already been filled
            collisionEffects: [] // Ball collision sparkle effects
        };
        
        let wallDirection = 'horizontal';
        let mouseX = -100;
        let mouseY = -100;
        const WALL_THICKNESS = 6;
        const WALL_SPEED = 6;
        const GRID_SIZE = 10;
        const GRID_COLS = canvas.width / GRID_SIZE;
        const GRID_ROWS = canvas.height / GRID_SIZE;
        
        // No boundary walls - we'll handle boundaries manually for better control
        
        
        function initLevel() {
            // Remove old balls and walls
            game.balls.forEach(ball => World.remove(world, ball.body));
            game.completedWalls.forEach(wall => World.remove(world, wall));
            
            game.balls = [];
            game.completedWalls = [];
            game.buildingWalls = [];
            game.wallsLeft = 5 + game.level * 2;
            game.permanentlyFilled.clear(); // Reset filled areas for new level
            
            const numBalls = Math.min(game.level + 1, 10);
            const speed = 2.5 + game.level * 0.4;
            const usedAngles = new Set();
            
            for (let i = 0; i < numBalls; i++) {
                // Ensure unique angle for each ball
                let angle;
                do {
                    angle = Math.random() * Math.PI * 2;
                } while (usedAngles.has(Math.floor(angle * 10)));
                usedAngles.add(Math.floor(angle * 10));
                
                const ballSpeed = speed * (0.9 + Math.random() * 0.2);
                
                const body = Bodies.circle(
                    canvas.width / 2 + (Math.random() - 0.5) * 100,
                    canvas.height / 2 + (Math.random() - 0.5) * 100,
                    8,
                    {
                        isStatic: true, // Make static so Matter.js doesn't move it
                        isSensor: true, // Allow overlap for flood fill detection
                        label: 'ball'
                    }
                );
                
                World.add(world, body);
                
                game.balls.push({
                    body: body,
                    color: ['#9333ea', '#ec4899', '#3b82f6', '#10b981'][i % 4],
                    trail: [],
                    baseSpeed: ballSpeed, // Base speed for this ball
                    speed: ballSpeed,
                    vx: Math.cos(angle) * ballSpeed,
                    vy: Math.sin(angle) * ballSpeed
                });
            }
            
            updateUI();
            showMessage(`Level ${game.level} - Fill ${game.goalPercent}%!`);
        }
        
        function updateUI() {
            document.getElementById('level').textContent = game.level;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('walls').textContent = game.wallsLeft;
            document.getElementById('direction').textContent = wallDirection.charAt(0).toUpperCase() + wallDirection.slice(1);
            document.getElementById('goal').textContent = game.goalPercent + '%';
            
            const filledPercent = calculateFilledPercent();
            document.getElementById('filled').textContent = filledPercent + '%';
        }
        
        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        
        function updateBuildingWall() {
            // Update all building walls
            game.buildingWalls = game.buildingWalls.filter((wall, wallIndex) => {
                if (wall.direction === 'horizontal') {
                    // Extend wall in both directions
                    const newWidth = wall.width + WALL_SPEED * 2;
                    const newX = wall.x - WALL_SPEED;
                    
                    // Check left extension
                    let leftBlocked = false;
                    if (newX <= 0) {
                        wall.x = 0;
                        leftBlocked = true;
                    } else {
                        // Check for completed wall collision on left
                        let leftWallX = null;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                                if (bounds.max.x >= newX && bounds.max.x <= wall.x) {
                                    if (leftWallX === null || bounds.max.x > leftWallX) {
                                        leftWallX = bounds.max.x;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on left
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            const otherRight = otherWall.x + otherWall.width;
                            if (wall.y + WALL_THICKNESS > otherWall.y && wall.y < otherWall.y + otherWall.height) {
                                if (otherRight >= newX && otherRight <= wall.x) {
                                    if (leftWallX === null || otherRight > leftWallX) {
                                        leftWallX = otherRight;
                                    }
                                }
                            }
                        });
                        
                        if (leftWallX !== null) {
                            wall.x = leftWallX;
                            leftBlocked = true;
                        } else {
                            wall.x = newX;
                        }
                    }
                    
                    // Check right extension
                    let rightBlocked = false;
                    const newRightEdge = wall.x + newWidth;
                    if (newRightEdge >= canvas.width) {
                        wall.width = canvas.width - wall.x;
                        rightBlocked = true;
                    } else {
                        // Check for completed wall collision on right
                        let rightWallX = null;
                        const currentRightEdge = wall.x + wall.width;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.y + WALL_THICKNESS > bounds.min.y && wall.y < bounds.max.y) {
                                if (bounds.min.x <= newRightEdge && bounds.min.x >= currentRightEdge) {
                                    if (rightWallX === null || bounds.min.x < rightWallX) {
                                        rightWallX = bounds.min.x;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on right
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            if (wall.y + WALL_THICKNESS > otherWall.y && wall.y < otherWall.y + otherWall.height) {
                                if (otherWall.x <= newRightEdge && otherWall.x >= currentRightEdge) {
                                    if (rightWallX === null || otherWall.x < rightWallX) {
                                        rightWallX = otherWall.x;
                                    }
                                }
                            }
                        });
                        
                        if (rightWallX !== null) {
                            wall.width = rightWallX - wall.x;
                            rightBlocked = true;
                        } else {
                            wall.width = newWidth;
                        }
                    }
                    
                    const hitBall = checkBallCollision(wall);
                    if ((leftBlocked && rightBlocked) || hitBall) {
                        completeWall(wall, hitBall);
                        return false; // Remove from array
                    }
                } else {
                    // Vertical wall
                    const newHeight = wall.height + WALL_SPEED * 2;
                    const newY = wall.y - WALL_SPEED;
                    
                    // Check top extension
                    let topBlocked = false;
                    if (newY <= 0) {
                        wall.y = 0;
                        topBlocked = true;
                    } else {
                        // Check for completed wall collision on top
                        let topWallY = null;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                                if (bounds.max.y >= newY && bounds.max.y <= wall.y) {
                                    if (topWallY === null || bounds.max.y > topWallY) {
                                        topWallY = bounds.max.y;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on top
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            const otherBottom = otherWall.y + otherWall.height;
                            if (wall.x + WALL_THICKNESS > otherWall.x && wall.x < otherWall.x + otherWall.width) {
                                if (otherBottom >= newY && otherBottom <= wall.y) {
                                    if (topWallY === null || otherBottom > topWallY) {
                                        topWallY = otherBottom;
                                    }
                                }
                            }
                        });
                        
                        if (topWallY !== null) {
                            wall.y = topWallY;
                            topBlocked = true;
                        } else {
                            wall.y = newY;
                        }
                    }
                    
                    // Check bottom extension
                    let bottomBlocked = false;
                    const newBottomEdge = wall.y + newHeight;
                    if (newBottomEdge >= canvas.height) {
                        wall.height = canvas.height - wall.y;
                        bottomBlocked = true;
                    } else {
                        // Check for completed wall collision on bottom
                        let bottomWallY = null;
                        const currentBottomEdge = wall.y + wall.height;
                        game.completedWalls.forEach(w => {
                            const bounds = w.bounds;
                            if (wall.x + WALL_THICKNESS > bounds.min.x && wall.x < bounds.max.x) {
                                if (bounds.min.y <= newBottomEdge && bounds.min.y >= currentBottomEdge) {
                                    if (bottomWallY === null || bounds.min.y < bottomWallY) {
                                        bottomWallY = bounds.min.y;
                                    }
                                }
                            }
                        });
                        
                        // Check for other building wall collision on bottom
                        game.buildingWalls.forEach((otherWall, otherIndex) => {
                            if (otherIndex === wallIndex) return;
                            if (wall.x + WALL_THICKNESS > otherWall.x && wall.x < otherWall.x + otherWall.width) {
                                if (otherWall.y <= newBottomEdge && otherWall.y >= currentBottomEdge) {
                                    if (bottomWallY === null || otherWall.y < bottomWallY) {
                                        bottomWallY = otherWall.y;
                                    }
                                }
                            }
                        });
                        
                        if (bottomWallY !== null) {
                            wall.height = bottomWallY - wall.y;
                            bottomBlocked = true;
                        } else {
                            wall.height = newHeight;
                        }
                    }
                    
                    const hitBall = checkBallCollision(wall);
                    if ((topBlocked && bottomBlocked) || hitBall) {
                        completeWall(wall, hitBall);
                        return false; // Remove from array
                    }
                }
                
                return true; // Keep in array
            });
        }
        
        function checkBallCollision(wall) {
            return game.balls.some(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                return pos.x + radius > wall.x && pos.x - radius < wall.x + wall.width &&
                       pos.y + radius > wall.y && pos.y - radius < wall.y + wall.height;
            });
        }
        
        function completeWall(wall, hitBall) {
            if (hitBall) {
                game.lives--;
                showMessage('Hit by ball! Lost a life!');
                updateUI();
                
                if (game.lives <= 0) {
                    gameOver();
                    return;
                }
            } else {
                const wallBody = Bodies.rectangle(
                    wall.x + wall.width / 2,
                    wall.y + wall.height / 2,
                    wall.width,
                    wall.height,
                    { 
                        isStatic: true, 
                        label: 'wall',
                        restitution: 1,
                        friction: 0,
                        slop: 0
                    }
                );
                
                World.add(world, wallBody);
                game.completedWalls.push(wallBody);
                
                // Calculate filled percent and create falling sections
                const filledPercent = calculateFilledPercent();
                createFallingSections();
                
                if (filledPercent >= game.goalPercent) {
                    levelComplete();
                    return;
                }
                
                if (game.wallsLeft <= 0 && game.buildingWalls.length === 0) {
                    showMessage('No walls left!');
                    setTimeout(() => {
                        game.lives--;
                        if (game.lives <= 0) {
                            gameOver();
                        } else {
                            initLevel();
                        }
                    }, 2000);
                    return;
                }
                
                showMessage(`${game.wallsLeft} walls left - ${filledPercent}% filled`);
                updateUI();
            }
        }
        
        function calculateFilledPercent() {
            const accessible = new Set();
            
            // Flood fill from each ball position
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            const totalCells = GRID_COLS * GRID_ROWS;
            const accessibleCells = accessible.size;
            const filledCells = totalCells - accessibleCells;
            
            return Math.floor((filledCells / totalCells) * 100);
        }
        
        function createFallingSections() {
            console.log('=== Creating Falling Sections ===');
            // Get all cells accessible from balls
            const ballAccessible = new Set();
            game.balls.forEach((ball, idx) => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                console.log(`Ball ${idx} at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}) -> grid (${col}, ${row})`);
                floodFill(col, row, ballAccessible);
            });
            console.log(`Total accessible cells: ${ballAccessible.size}`);
            
            // Find all non-accessible regions that aren't walls
            const filledRegions = [];
            const processed = new Set();
            
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    
                    // Skip if already processed or accessible or already permanently filled
                    if (processed.has(key) || ballAccessible.has(key) || game.permanentlyFilled.has(key)) continue;
                    
                    const cellMinX = col * GRID_SIZE;
                    const cellMaxX = (col + 1) * GRID_SIZE;
                    const cellMinY = row * GRID_SIZE;
                    const cellMaxY = (row + 1) * GRID_SIZE;
                    
                    // Check if this cell intersects with a wall
                    let blockedByWall = false;
                    for (let wall of game.completedWalls) {
                        const bounds = wall.bounds;
                        if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                              cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                            blockedByWall = true;
                            break;
                        }
                    }
                    
                    if (!blockedByWall) {
                        // Found a filled cell - gather the entire region
                        const region = [];
                        const stack = [[col, row]];
                        const regionSet = new Set();
                        
                        while (stack.length > 0) {
                            const [c, r] = stack.pop();
                            const k = `${c},${r}`;
                            
                            if (c < 0 || c >= GRID_COLS || r < 0 || r >= GRID_ROWS) continue;
                            if (regionSet.has(k) || ballAccessible.has(k) || processed.has(k)) continue;
                            
                            const cellMinX = c * GRID_SIZE;
                            const cellMaxX = (c + 1) * GRID_SIZE;
                            const cellMinY = r * GRID_SIZE;
                            const cellMaxY = (r + 1) * GRID_SIZE;
                            
                            // Check if cell intersects with a wall
                            let blockedByWall = false;
                            for (let wall of game.completedWalls) {
                                const bounds = wall.bounds;
                                if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                                      cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                                    blockedByWall = true;
                                    break;
                                }
                            }
                            
                            if (blockedByWall) {
                                processed.add(k);
                                continue;
                            }
                            
                            regionSet.add(k);
                            processed.add(k);
                            region.push([c, r]);
                            
                            stack.push([c + 1, r], [c - 1, r], [c, r + 1], [c, r - 1]);
                        }
                        
                        if (region.length > 5) {
                            filledRegions.push(region);
                        }
                    } else {
                        processed.add(key);
                    }
                }
            }
            
            console.log(`Found ${filledRegions.length} filled regions`);
            
            // Create falling animation for each filled region
            filledRegions.forEach((region, idx) => {
                console.log(`Region ${idx}: ${region.length} cells`);
                const minCol = Math.min(...region.map(([c, r]) => c));
                const maxCol = Math.max(...region.map(([c, r]) => c));
                const minRow = Math.min(...region.map(([c, r]) => r));
                const maxRow = Math.max(...region.map(([c, r]) => r));
                console.log(`  Bounds: cols ${minCol}-${maxCol}, rows ${minRow}-${maxRow}`);
                
                // Mark all cells in this region as permanently filled
                region.forEach(([c, r]) => {
                    game.permanentlyFilled.add(`${c},${r}`);
                });
                
                game.fallingSections.push({
                    x: minCol * GRID_SIZE,
                    y: minRow * GRID_SIZE,
                    width: (maxCol - minCol + 1) * GRID_SIZE,
                    height: (maxRow - minRow + 1) * GRID_SIZE,
                    scale: 1,
                    opacity: 1,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    cells: region
                });
            });
        }
        
        function updateFallingSections() {
            game.fallingSections = game.fallingSections.filter(section => {
                section.scale -= 0.025;
                section.rotation += section.rotationSpeed;
                section.opacity -= 0.025;
                section.y += 3; // Fall downward
                return section.scale > 0 && section.opacity > 0;
            });
        }
        
        function updateBallSpeeds() {
            const totalArea = GRID_COLS * GRID_ROWS;
            
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                
                // Calculate accessible area for this ball
                const accessible = new Set();
                floodFill(col, row, accessible);
                const ballArea = accessible.size;
                
                // Speed increases gradually as area decreases
                // Uses squared formula for gentle start, stronger acceleration at small areas
                const areaRatio = Math.max(ballArea / totalArea, 0.01);
                const reduction = 1 - areaRatio; // How much area is gone (0 to 1)
                const speedMultiplier = 1 + (reduction * reduction * 3); // Max ~4x at very small areas
                
                // Update ball speed
                ball.speed = ball.baseSpeed * speedMultiplier;
                
                // Adjust velocity to match new speed while maintaining direction
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (currentSpeed > 0.1) {
                    const ratio = ball.speed / currentSpeed;
                    ball.vx *= ratio;
                    ball.vy *= ratio;
                }
            });
        }
        
        function updateBallPhysics() {
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                // Simple movement
                let x = pos.x + ball.vx;
                let y = pos.y + ball.vy;
                
                // Boundary collisions with reflection
                if (x - radius < 0) {
                    x = radius;
                    ball.vx = Math.abs(ball.vx);
                } else if (x + radius > canvas.width) {
                    x = canvas.width - radius;
                    ball.vx = -Math.abs(ball.vx);
                }
                
                if (y - radius < 0) {
                    y = radius;
                    ball.vy = Math.abs(ball.vy);
                } else if (y + radius > canvas.height) {
                    y = canvas.height - radius;
                    ball.vy = -Math.abs(ball.vy);
                }
                
                // Ball-to-ball collisions (with limited separation to prevent escaping)
                for (let j = 0; j < game.balls.length; j++) {
                    const otherBall = game.balls[j];
                    if (otherBall === ball) continue;
                    
                    const otherPos = otherBall.body.position;
                    const dx = x - otherPos.x;
                    const dy = y - otherPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = radius * 2;
                    
                    if (distance < minDist && distance > 0.1) {
                        // Only create effect once per collision (check if not already created this frame)
                        if (!ball.collisionCooldown) {
                            const collisionX = (x + otherPos.x) / 2;
                            const collisionY = (y + otherPos.y) / 2;
                            createCollisionEffect(collisionX, collisionY, ball.color, otherBall.color);
                            ball.collisionCooldown = true;
                            setTimeout(() => ball.collisionCooldown = false, 100);
                        }
                        
                        // Separate balls with limited displacement
                        const overlap = minDist - distance;
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const separation = Math.min(overlap / 2, 2); // Limit separation to 2 pixels max
                        x += nx * separation;
                        y += ny * separation;
                        
                        // Elastic collision response
                        const dvx = ball.vx - otherBall.vx;
                        const dvy = ball.vy - otherBall.vy;
                        const dotProduct = dvx * nx + dvy * ny;
                        
                        if (dotProduct < 0) {
                            ball.vx -= dotProduct * nx;
                            ball.vy -= dotProduct * ny;
                        }
                    }
                }
                
                // Clamp to boundaries after ball collision (prevent escaping)
                x = Math.max(radius, Math.min(canvas.width - radius, x));
                y = Math.max(radius, Math.min(canvas.height - radius, y));
                
                // Wall collisions - simple overlap check
                for (const wall of game.completedWalls) {
                    const bounds = wall.bounds;
                    const wallWidth = bounds.max.x - bounds.min.x;
                    const wallHeight = bounds.max.y - bounds.min.y;
                    
                    // Check if ball overlaps wall
                    if (x + radius > bounds.min.x && x - radius < bounds.max.x &&
                        y + radius > bounds.min.y && y - radius < bounds.max.y) {
                        
                        // Mark wall as hit
                        wall.hitTime = Date.now();
                        
                        // Determine wall orientation and reflect
                        if (wallWidth > wallHeight) {
                            // Horizontal wall
                            if (ball.vy > 0) {
                                y = bounds.min.y - radius;
                            } else {
                                y = bounds.max.y + radius;
                            }
                            ball.vy = -ball.vy;
                        } else {
                            // Vertical wall
                            if (ball.vx > 0) {
                                x = bounds.min.x - radius;
                            } else {
                                x = bounds.max.x + radius;
                            }
                            ball.vx = -ball.vx;
                        }
                    }
                }
                
                // Maintain constant speed
                const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (currentSpeed > 0) {
                    ball.vx = (ball.vx / currentSpeed) * ball.speed;
                    ball.vy = (ball.vy / currentSpeed) * ball.speed;
                }
                
                // Update position
                Body.setPosition(ball.body, { x, y });
            });
        }
        
        function createCollisionEffect(x, y, color1, color2) {
            // Create sparkle particles at collision point
            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                game.collisionEffects.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    color: i % 2 === 0 ? color1 : color2,
                    size: 3 + Math.random() * 3
                });
            }
            
            // Add a bright flash at the center
            game.collisionEffects.push({
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                life: 1.0,
                color: '#ffffff',
                size: 15,
                isFlash: true
            });
        }
        
        function updateCollisionEffects() {
            game.collisionEffects = game.collisionEffects.filter(effect => {
                effect.x += effect.vx;
                effect.y += effect.vy;
                effect.life -= 0.05;
                effect.size *= 0.95;
                return effect.life > 0;
            });
        }
        
        function updateBallTrails() {
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                ball.trail.push({ x: pos.x, y: pos.y });
                
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                const maxTrailLength = Math.floor(8 + speed * 2); // Shorter trails for better performance
                
                if (ball.trail.length > maxTrailLength) {
                    ball.trail.shift();
                }
            });
        }
        
        function floodFill(startCol, startRow, visited) {
            const stack = [[startCol, startRow]];
            
            while (stack.length > 0) {
                const [col, row] = stack.pop();
                
                if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) continue;
                
                const key = `${col},${row}`;
                if (visited.has(key)) continue;
                
                // Check if this grid cell intersects with any wall
                const cellMinX = col * GRID_SIZE;
                const cellMaxX = (col + 1) * GRID_SIZE;
                const cellMinY = row * GRID_SIZE;
                const cellMaxY = (row + 1) * GRID_SIZE;
                
                let blockedByWall = false;
                for (let wall of game.completedWalls) {
                    const bounds = wall.bounds;
                    // Check if cell area intersects with wall bounds
                    if (!(cellMaxX < bounds.min.x || cellMinX > bounds.max.x ||
                          cellMaxY < bounds.min.y || cellMinY > bounds.max.y)) {
                        blockedByWall = true;
                        break;
                    }
                }
                
                if (blockedByWall) continue;
                
                visited.add(key);
                
                stack.push([col + 1, row], [col - 1, row], [col, row + 1], [col, row - 1]);
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a0a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw filled areas
            const accessible = new Set();
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const col = Math.floor(pos.x / GRID_SIZE);
                const row = Math.floor(pos.y / GRID_SIZE);
                floodFill(col, row, accessible);
            });
            
            // Draw filled areas in one pass
            ctx.fillStyle = '#2d1b4e';
            ctx.beginPath();
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const key = `${col},${row}`;
                    if (!accessible.has(key)) {
                        ctx.rect(col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            ctx.fill()
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(147, 51, 234, 0.15)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
            
            // Draw completed walls
            game.completedWalls.forEach(wall => {
                const bounds = wall.bounds;
                const now = Date.now();
                const timeSinceHit = wall.hitTime ? now - wall.hitTime : 9999;
                const blinkDuration = 200; // milliseconds
                
                // Determine color based on hit time
                if (timeSinceHit < blinkDuration) {
                    const progress = timeSinceHit / blinkDuration;
                    ctx.fillStyle = '#10b981'; // Green
                    ctx.shadowColor = '#10b981';
                    ctx.shadowBlur = 15 * (1 - progress); // Fade shadow
                } else {
                    ctx.fillStyle = '#9333ea'; // Purple
                    ctx.shadowColor = '#9333ea';
                    ctx.shadowBlur = 10;
                }
                
                ctx.fillRect(
                    bounds.min.x,
                    bounds.min.y,
                    bounds.max.x - bounds.min.x,
                    bounds.max.y - bounds.min.y
                );
            });
            
            // Draw building walls
            ctx.fillStyle = '#ec4899';
            ctx.shadowColor = '#ec4899';
            game.buildingWalls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });
            
            ctx.shadowBlur = 0;
            
            // Draw falling sections
            game.fallingSections.forEach((section, idx) => {
                ctx.save();
                ctx.globalAlpha = section.opacity;
                ctx.translate(section.x + section.width / 2, section.y + section.height / 2);
                ctx.rotate(section.rotation);
                ctx.scale(section.scale, section.scale);
                
                // Create gradient for falling sections
                const gradient = ctx.createLinearGradient(
                    -section.width / 2, -section.height / 2,
                    section.width / 2, section.height / 2
                );
                gradient.addColorStop(0, '#ec4899');
                gradient.addColorStop(0.5, '#9333ea');
                gradient.addColorStop(1, '#3b82f6');
                
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ec4899';
                ctx.fillRect(-section.width / 2, -section.height / 2, section.width, section.height);
                
                ctx.restore();
            });
            
            // Draw ball tracers
            game.balls.forEach(ball => {
                if (ball.trail.length > 1) {
                    ctx.save();
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    for (let i = 1; i < ball.trail.length; i++) {
                        const progress = i / ball.trail.length;
                        const alpha = progress * 0.4;
                        
                        // Draw outer glow (wider, more intense)
                        ctx.strokeStyle = ball.color;
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.lineWidth = 12;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = ball.color;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                        
                        // Draw bright core (wider, brighter)
                        ctx.globalAlpha = alpha * 0.6;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                        
                        // Add extra bright center line
                        ctx.globalAlpha = alpha * 0.7;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.moveTo(ball.trail[i - 1].x, ball.trail[i - 1].y);
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            });
            
            // Draw collision effects
            game.collisionEffects.forEach(effect => {
                ctx.save();
                ctx.globalAlpha = effect.life;
                
                if (effect.isFlash) {
                    // Bright flash at center
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = effect.color;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Sparkle particles
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = effect.color;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add white core to sparkles
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
            
            // Draw balls
            game.balls.forEach(ball => {
                const pos = ball.body.position;
                const radius = ball.body.circleRadius;
                
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = ball.color;
                
                const grad = ctx.createRadialGradient(
                    pos.x - radius * 0.3, pos.y - radius * 0.3, radius * 0.1,
                    pos.x, pos.y, radius
                );
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.3, ball.color);
                grad.addColorStop(1, darkenColor(ball.color, 0.4));
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Rim light
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 0;
                ctx.stroke();
                
                // Highlight shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(pos.x - radius * 0.35, pos.y - radius * 0.35, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Draw cursor direction indicator and crosshair
            if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height && 
                game.isRunning && !game.isPaused) {
                ctx.save();
                
                // Direction line (only when not building)
                if (!game.buildingWall) {
                    ctx.strokeStyle = 'rgba(236, 72, 153, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ec4899';
                    
                    ctx.beginPath();
                    if (wallDirection === 'horizontal') {
                        ctx.moveTo(0, mouseY);
                        ctx.lineTo(canvas.width, mouseY);
                    } else {
                        ctx.moveTo(mouseX, 0);
                        ctx.lineTo(mouseX, canvas.height);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Crosshair
                ctx.strokeStyle = '#ec4899';
                ctx.fillStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ec4899';
                
                ctx.beginPath();
                ctx.moveTo(mouseX - 10, mouseY);
                ctx.lineTo(mouseX - 3, mouseY);
                ctx.moveTo(mouseX + 3, mouseY);
                ctx.lineTo(mouseX + 10, mouseY);
                ctx.moveTo(mouseX, mouseY - 10);
                ctx.lineTo(mouseX, mouseY - 3);
                ctx.moveTo(mouseX, mouseY + 3);
                ctx.lineTo(mouseX, mouseY + 10);
                ctx.stroke();
                
                // Center dot
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function darkenColor(color, factor) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function gameLoop() {
            if (!game.isRunning) return;
            
            if (!game.isPaused) {
                updateBallSpeeds();
                updateBallPhysics();
                updateBuildingWall();
                updateFallingSections();
                updateBallTrails();
                updateCollisionEffects();
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function levelComplete() {
            game.isRunning = false;
            showMessage(`Level ${game.level} Complete!`);
            setTimeout(() => {
                game.level++;
                game.isRunning = true;
                initLevel();
                gameLoop();
            }, 2000);
        }
        
        function gameOver() {
            game.isRunning = false;
            showMessage('Game Over! Click Start to play again.');
        }
        
        // Event listeners
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseX = -100;
            mouseY = -100;
        });
        
        canvas.addEventListener('click', e => {
            if (!game.isRunning || game.isPaused || game.wallsLeft <= 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if click is in a fallen area
            const col = Math.floor(x / GRID_SIZE);
            const row = Math.floor(y / GRID_SIZE);
            const key = `${col},${row}`;
            
            if (game.permanentlyFilled.has(key)) {
                showMessage('Cannot place wall in fallen area!');
                return;
            }
            
            game.wallsLeft--;
            updateUI();
            
            if (wallDirection === 'horizontal') {
                game.buildingWalls.push({
                    x: x,
                    y: y - WALL_THICKNESS / 2,
                    width: 0,
                    height: WALL_THICKNESS,
                    direction: 'horizontal'
                });
            } else {
                game.buildingWalls.push({
                    x: x - WALL_THICKNESS / 2,
                    y: y,
                    width: WALL_THICKNESS,
                    height: 0,
                    direction: 'vertical'
                });
            }
        });
        
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
            updateUI();
        });
        
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                wallDirection = wallDirection === 'horizontal' ? 'vertical' : 'horizontal';
                updateUI();
            }
        });
        
        // Power-up controls
        const powerupItems = document.querySelectorAll('.powerup-item');
        
        document.addEventListener('wheel', e => {
            if (e.deltaY > 0) {
                game.selectedPowerup = (game.selectedPowerup + 1) % powerupItems.length;
            } else {
                game.selectedPowerup = (game.selectedPowerup - 1 + powerupItems.length) % powerupItems.length;
            }
            updatePowerupUI();
        });
        
        document.addEventListener('mousedown', e => {
            if (e.button === 1) {
                e.preventDefault();
                activatePowerup(game.selectedPowerup);
            }
        });
        
        function updatePowerupUI() {
            powerupItems.forEach((item, index) => {
                item.classList.remove('selected');
                if (index === game.selectedPowerup) {
                    item.classList.add('selected');
                }
            });
        }
        
        function activatePowerup(index) {
            const powerupNames = ['Freeze Time', 'Electron Beam', 'Ball Destruction', 'Bounce Update', 'Slow Motion', 'Extra Life'];
            showMessage(`${powerupNames[index]} - Coming Soon!`);
        }
        
        updatePowerupUI();
        
        document.getElementById('startBtn').addEventListener('click', () => {
            game.level = 1;
            game.lives = 5;
            game.isRunning = true;
            game.isPaused = false;
            initLevel();
            gameLoop();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            game.isPaused = !game.isPaused;
            document.getElementById('pauseBtn').textContent = game.isPaused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('restartBtn').addEventListener('click', () => {
            if (game.isRunning) {
                initLevel();
            }
        });
        
        draw();
    </script>
</body>
</html>
